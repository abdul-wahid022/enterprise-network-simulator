#include <iostream>
#include <string>
#include <cstdint>  
#include <limits>     
#include <queue>
#include <vector>
#include <map>
#include <iomanip>
#include <algorithm>
#include <set>
#include <sstream>
#include <thread>
#include <fstream>
#include <ctime>
#include <chrono>
#include <thread>
using namespace std;
// âœ… ADD AFTER LINE 20 (after using namespace std;)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK CONSTANTS - ADD THIS ENTIRE BLOCK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

namespace NetworkConstants {
    // Traceroute limits
    const int MAX_HOPS = 30;
    const int MAX_TRACEROUTE_DEPTH = 30;
    
    // Syslog configuration
    const int MAX_SYSLOG_ENTRIES = 1000;
    
    // Network parameters
    const int DEFAULT_TTL = 64;
    const int DEFAULT_MTU = 1500;
    const int ARP_TTL_SECONDS = 300;
    const int NAT_TIMEOUT_SECONDS = 300;
    
    // DHCP configuration
    const int DHCP_POOL_START = 20;
    const int DHCP_POOL_END = 100;
    
        const int NAT_POOL_START = 100;
    const int NAT_POOL_SIZE = 50;
    
    // Latency ranges (milliseconds)
    const int LATENCY_INTERNET_MIN = 10;
    const int LATENCY_INTERNET_MAX = 25;
    const int LATENCY_DMZ_MIN = 2;
    const int LATENCY_DMZ_MAX = 7;
    const int LATENCY_WAN_MIN = 1;
    const int LATENCY_WAN_MAX = 3;
    const int LATENCY_LOCAL_MIN = 1;
    const int LATENCY_LOCAL_MAX = 2;
    
    // Port ranges
    const int EPHEMERAL_PORT_START = 49152;
    const int EPHEMERAL_PORT_RANGE = 10000;
}

// ANSI Color Codes
#define RESET   "\033[0m"
#define CYAN    "\033[36m"
#define YELLOW  "\033[33m"
#define WHITE   "\033[37m"
#define GREEN   "\033[32m"
#define RED     "\033[31m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"

// Device Types
enum DeviceType {
    ROUTER, L3_SWITCH, L2_SWITCH, FIREWALL, SERVER,
    PC, LAPTOP, PHONE, EPHONE, WLC, ACCESS_POINT, TABLET
};

// Department Enum
enum Department {
    MANAGEMENT, IT, SALES, FINANCE, HR,
    CORE, VOICE, WIRELESS, SECURITY, DMZ, INTERNET
};

// DHCP Pool Structure
struct DHCPPool {
    string poolName;
    string subnet;
    string vlan;
    int startIP;
    int endIP;
    int currentIP;
    set<int> usedIPs;
    
    int getUsedCount() const { return usedIPs.size(); }
    int getTotalCount() const { return endIP - startIP + 1; }
    int getAvailableCount() const { return getTotalCount() - getUsedCount(); }
};

// Connection Structure
struct Connection {
    string targetDevice;
    string protocol;
};

// Email Structure
struct Email {
    string from;
    string to;
    string subject;
    string body;
    string timestamp;
    bool isRead;
};

// Call Log Structure
struct CallLog {
    string from;
    string to;
    string duration;
    string timestamp;
};
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK TOOLS DATA STRUCTURES - ADD BEFORE Device STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Network Interface Structure (for IPConfig)
struct NetworkInterface {
    string interfaceName;        // "Ethernet0", "GigabitEthernet0/0"
    string macAddress;           // "00:1A:2B:3C:4D:5E"
    string ipAddress;
    string subnetMask;
    string defaultGateway;
    string dnsServer;
    bool dhcpEnabled;
    string dhcpServer;
    int mtu;                     // Maximum Transmission Unit
    long long bytesReceived;
    long long bytesSent;
    int packetsReceived;
    int packetsSent;
    string interfaceStatus;      // "UP", "DOWN"
};

// Connection State Structure (for Netstat)
struct ConnectionState {
    string protocol;             // "TCP", "UDP", "ICMP"
    string localAddress;
    int localPort;
    string remoteAddress;
    int remotePort;
    string state;               // "ESTABLISHED", "LISTENING", "TIME_WAIT"
    int pid;
    string processName;
    string timestamp;
};

struct ListeningPort {
    int port;
    string protocol;
    string service;
    string bindAddress;
    bool isActive;
};

// ARP Entry Structure
struct ARPEntry {
    string ipAddress;
    string macAddress;
    string type;                // "dynamic", "static"
    string interfaceName;
    time_t timestamp;
    int ttl;                    // Time to live (seconds)
};

// Traceroute Hop Structure
struct HopRecord {
    int hopNumber;
    string deviceId;
    string deviceIP;
    string deviceName;
    int latency;
    bool reachable;
    string incomingInterface;
    string outgoingInterface;
};
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTING & SWITCHING STRUCTURES - ADD AFTER HopRecord
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Route Entry Structure
struct RouteEntry {
    string destinationNetwork;   // "0.0.0.0/0" (default), "10.10.10.0/24"
    string subnetMask;           // "0.0.0.0", "255.255.255.0"
    string nextHop;              // "192.168.1.1" or "0.0.0.0" (connected)
    string outInterface;         // "GigabitEthernet0/0", "Vlan10"
    int metric;                  // Route priority (lower is better)
    string protocol;             // "Static", "OSPF", "Connected"
    bool isActive;
};

// NAT Translation Entry
struct NATEntry {
    string insideLocal;          // Private IP (10.10.10.1)
    string insideGlobal;         // Public IP after NAT (203.0.113.100)
    int insidePort;
    int outsidePort;
    string protocol;             // "TCP", "UDP", "ICMP"
    time_t timestamp;
    string state;                // "ACTIVE", "EXPIRED"
};

// VLAN Configuration
struct VLANConfig {
    int vlanId;                  // 10, 20, 30, etc.
    string vlanName;             // "Management", "IT", "Sales"
    string subnet;               // "10.10.10.0/24"
    vector<string> assignedPorts; // Which ports are in this VLAN
    bool isActive;
};

// Trunk Link
struct TrunkLink {
    string localDevice;
    string localInterface;
    string remoteDevice;
    string remoteInterface;
    vector<int> allowedVLANs;    // VLANs allowed on trunk
    string encapsulation;        // "802.1Q"
    bool isActive;
};

// OSPF Neighbor
struct OSPFNeighbor {
    string neighborId;           // Router ID
    string neighborIP;
    string interface_;           // Local interface
    string state;                // "FULL", "2WAY", "DOWN"
    int priority;
    string deadTime;             // "00:00:35"
};

// HSRP Status
struct HSRPStatus {
    string deviceId;
    int groupNumber;
    string virtualIP;
    string state;                // "Active", "Standby", "Listen"
    int priority;
    string preempt;              // "Enabled", "Disabled"
};
enum DeviceStatus {
    ONLINE,
    OFFLINE,
    UNREACHABLE,
    NO_UPLINK,
    WIRELESS_DOWN,
    SERVICE_DOWN,
    REMOVED
};

// NOW comes the Device Structure
struct Device {
    string id;
    string name;
    string ipAddress;
    string subnet;
    string vlan;
    string department;
    DeviceType type;
    vector<Connection> connections;
    bool isActive;
    bool isDHCP;
    DeviceStatus status;
    string offlineReason;
    string removedTimestamp;
    bool isCriticalService;
    
    // NEW FIELDS
    string macAddress;
    vector<NetworkInterface> interfaces;
    vector<ConnectionState> activeConnections;
    vector<ListeningPort> listeningPorts;
        // â¬‡ï¸â¬‡ï¸â¬‡ï¸ ADD THESE NEW FIELDS â¬‡ï¸â¬‡ï¸â¬‡ï¸
    vector<RouteEntry> routingTable;        // For L3 devices
    vector<VLANConfig> vlans;               // For switches
    vector<TrunkLink> trunks;               // For switches
    vector<OSPFNeighbor> ospfNeighbors;     // For routers
    HSRPStatus hsrpStatus;                  // For L3 switches
    bool natEnabled;                        // For firewalls/routers
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW STRUCTURES - PASTE THIS ENTIRE BLOCK HERE (AFTER LINE 88)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ping Record Structure
struct PingRecord {
    string sourceDevice;
    string sourceIP;
    string targetDevice;
    string targetIP;
    string timestamp;
    int latency;
    bool success;
    int ttl;
    int packetsSent;
    int packetsReceived;
    float packetLoss;
};

// Firewall ACL Rule Structure
struct ACLRule {
    int ruleNumber;
    string sourceNetwork;
    string destinationNetwork;
    string action;
    string protocol;
    string description;
    bool isActive;
};

// External Server Structure
struct ExternalServer {
    string id;
    string name;
    string ipAddress;
    string location;
    string provider;
    bool isReachable;
    vector<PingRecord> pingHistory;
    int totalRequests;
    int successfulRequests;
    string lastAccessTime;
};
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END OF NEW STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYSLOG SERVER STRUCTURES - ADD AFTER ExternalServer STRUCT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Syslog Severity Levels (RFC 5424)
enum SyslogSeverity {
    EMERGENCY = 0,   // System unusable
    ALERT = 1,       // Action must be taken immediately
    CRITICAL = 2,    // Critical conditions
    ERROR = 3,       // Error conditions
    WARNING = 4,     // Warning conditions
    NOTICE = 5,      // Normal but significant
    INFO = 6,        // Informational messages
    DEBUG = 7        // Debug-level messages
};

// Syslog Facility (Source of log)
enum SyslogFacility {
    NETWORK_MANAGEMENT = 0,
    DHCP_SERVER = 1,
    EMAIL_SERVER = 2,
    PHONE_SERVER = 3,
    WEB_SERVER = 4,
   FIREWALL_FACILITY = 5, 
    PING_SERVICE = 6,
    EXTERNAL_SERVERS = 7,
    USER_ACTION = 8,
    SYSTEM = 9
};

// Syslog Entry Structure
struct SyslogEntry {
    string timestamp;
    SyslogSeverity severity;
    SyslogFacility facility;
    string sourceDevice;
    string sourceIP;
    string eventType;
    string message;
    string username;
    
    string getSeverityString() const {
        const char* levels[] = {"EMERG", "ALERT", "CRIT", "ERROR", 
                               "WARN", "NOTICE", "INFO", "DEBUG"};
        return levels[severity];
    }
    
   string getFacilityString() const {
    const char* facilities[] = {"NET_MGMT", "DHCP", "EMAIL", "PHONE", 
                               "WEB", "FIREWALL", "PING", "EXT_SRV", 
                               "USER", "SYSTEM"};
    return facilities[facility];
}
    string getSeverityColor() const {
        if (severity <= CRITICAL) return RED;
        if (severity == ERROR) return MAGENTA;
        if (severity == WARNING) return YELLOW;
        if (severity == NOTICE) return CYAN;
        return WHITE;
    }
};
struct ServiceStatus {
    bool dhcpOnline;
    bool emailOnline;
    bool webOnline;
    string dhcpServerDevice;
    string emailServerDevice;
    string webServerDevice;
};

struct SyslogStats {
    int totalEvents = 0;
    int emergencyCount = 0;
    int alertCount = 0;
    int criticalCount = 0;
    int errorCount = 0;
    int warningCount = 0;
    int noticeCount = 0;
    int infoCount = 0;
    int debugCount = 0;
} syslogStats;
// âœ… ADD THIS AFTER CONSTANTS (Line ~280)

/**
 * @class NetworkSimulator
 * @brief Main network simulation engine
 * 
 * Encapsulates all network management functionality including:
 * - Device management (add/remove/search)
 * - Network tools (ping, traceroute, netstat)
 * - Server services (DHCP, Email, Phone, Syslog)
 * - Routing protocols (OSPF, HSRP, NAT)
 * 
 * @version 1.0.0
 * @author Cloud TAP Team
 */
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK ANALYSIS MODULE - Option 5
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


void networkAnalysisMenu();  
// Global Variables
map<string, Device> networkDevices;
map<string, DHCPPool> dhcpPools;
vector<Email> emailInbox;
vector<CallLog> callLogs;
map<string, string> emailDirectory;
map<string, string> phoneDirectory;
int deviceCounter = 1;
int totalDevices = 0;
int totalConnections = 0;

vector<PingRecord> globalPingHistory;
map<string, ExternalServer> externalServers;
vector<ACLRule> firewallACLs;
int aclRuleCounter = 10;
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK TOOLS GLOBAL VARIABLES - ADD AFTER EXISTING GLOBALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

map<string, vector<ARPEntry>> deviceARPTables;     // deviceId -> ARP entries
vector<HopRecord> globalTracerouteHistory;
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYSLOG GLOBAL VARIABLES - ADD AFTER EXISTING GLOBALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTING & SWITCHING GLOBAL VARIABLES - ADD AFTER EXISTING GLOBALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

map<string, vector<NATEntry>> natTables;           // deviceId -> NAT entries
map<string, vector<OSPFNeighbor>> ospfDatabase;    // deviceId -> OSPF neighbors
vector<TrunkLink> globalTrunkLinks;                // All trunk links in network

deque<SyslogEntry> syslogDatabase;
const int MAX_SYSLOG_ENTRIES = 1000;



// Utility Functions
string deviceTypeToString(DeviceType type) {
    string types[] = {"Router", "L3 Switch", "L2 Switch", "Firewall", "Server",
                      "PC", "Laptop", "Mobile Phone", "IP Phone", "WLC", "Access Point", "Tablet"};
    return types[type];
}

string deviceIcon(DeviceType type) {
    string icons[] = {"[R]", "[L3]", "[L2]", "[FW]", "[SRV]",
                      "[PC]", "[LAP]", "[PHN]", "[EPH]", "[WLC]", "[AP]", "[TAB]"};
    return icons[type];
}

string deptToString(Department dept) {
    string depts[] = {"Management", "IT", "Sales", "Finance", "HR",
                      "Core", "Voice", "Wireless", "Security", "DMZ", "Internet"};
    return depts[dept];
}

string getCurrentTime() {
    time_t now = time(0);
    char buf[80];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&now));
    return string(buf);
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT VALIDATION HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int getValidatedInt(const string& prompt, int min, int max) {
    int value;
    while (true) {
        cout << prompt;
        cin >> value;
        
        if (cin.fail()) {
            cin.clear();
            cin.ignore(10000, '\n');
            cout << RED << "âŒ Invalid input! Please enter a number.\n" << RESET;
            continue;
        }
        
        if (value < min || value > max) {
            cout << RED << "âŒ Value must be between " << min << " and " << max << "\n" << RESET;
            continue;
        }
        
        return value;
    }
}

string getValidatedDeviceID(const string& prompt) {
    string id;
    while (true) {
        cout << prompt;
        cin >> id;
        
        if (id.empty()) {
            cout << RED << "âŒ Device ID cannot be empty!\n" << RESET;
            continue;
        }
        
        transform(id.begin(), id.end(), id.begin(), ::toupper);
        
        if (networkDevices.find(id) == networkDevices.end()) {
            cout << RED << "âŒ Device '" << id << "' not found!\n" << RESET;
            cout << YELLOW << "ğŸ’¡ Tip: Use search (option 6) to find devices\n" << RESET;
            continue;
        }
        
        return id;
    }
}

bool confirmAction(const string& message) {
    cout << YELLOW << message << " (yes/no): " << RESET;
    string response;
    cin >> response;
    transform(response.begin(), response.end(), response.begin(), ::tolower);
    return (response == "yes" || response == "y");
}
// â¬…ï¸ ADD THIS FORWARD DECLARATION HERE (before getVLAN function)
void logToSyslog(SyslogSeverity severity, SyslogFacility facility,
                 const string& sourceDevice, const string& sourceIP,
                 const string& eventType, const string& message,
                 const string& username);

string getVLAN(DeviceType type, Department dept) {
    if (type == EPHONE) return "VLAN60";
    if (type == PHONE || type == TABLET) return "VLAN70";
    string vlans[] = {"VLAN10", "VLAN20", "VLAN30", "VLAN40", "VLAN50"};
    if (dept <= HR) return vlans[dept];
    return "-";
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS FOR DEVICE STATUS - ADD AFTER getVLAN()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string deviceStatusToString(DeviceStatus status) {
    switch(status) {
        case ONLINE: return "ğŸŸ¢ ONLINE";
        case OFFLINE: return "ğŸ”´ OFFLINE";
        case UNREACHABLE: return "ğŸ”´ UNREACHABLE";
        case NO_UPLINK: return "ğŸ”´ NO_UPLINK";
        case WIRELESS_DOWN: return "ğŸ”´ WIRELESS_DOWN";
        case SERVICE_DOWN: return "ğŸ”´ SERVICE_DOWN";
        case REMOVED: return "âš« REMOVED";
        default: return "â“ UNKNOWN";
    }
}

string deviceStatusReason(DeviceStatus status) {
    switch(status) {
        case ONLINE: return "Normal operation";
        case OFFLINE: return "Parent device removed";
        case UNREACHABLE: return "Lost network connection";
        case NO_UPLINK: return "Parent switch offline";
        case WIRELESS_DOWN: return "Access Point offline";
        case SERVICE_DOWN: return "Critical service unavailable";
        case REMOVED: return "Device removed from network";
        default: return "Unknown status";
    }
}

bool isCriticalServiceHost(const string& deviceId) {
    return (deviceId == "MGMT-SRV1");
}

vector<string> getConnectedDevices(const string& deviceId) {
    vector<string> connected;
    if (networkDevices.find(deviceId) == networkDevices.end()) return connected;
    
    for (const Connection& conn : networkDevices[deviceId].connections) {
        connected.push_back(conn.targetDevice);
    }
    return connected;
}

// âœ… REPLACE WITH THIS (Line ~550)
void findAllDependents(const string& deviceId, set<string>& dependents) {
    queue<string> toProcess;
    toProcess.push(deviceId);
    set<string> visited;  // Prevent loops
    
    while (!toProcess.empty()) {
        string current = toProcess.front();
        toProcess.pop();
        
        // Skip if already visited
        if (visited.count(current)) continue;
        visited.insert(current);
        
        vector<string> children = getConnectedDevices(current);
        for (const string& childId : children) {
            if (dependents.find(childId) == dependents.end() && childId != deviceId) {
                dependents.insert(childId);
                toProcess.push(childId);
            }
        }
    }
}

string getDeptSwitch(Department dept) {
    string switches[] = {"MGMT-SW1", "IT-SW1", "SALES-SW1", "FIN-SW1", "HR-SW1"};
    return dept <= HR ? switches[dept] : "";
}

string getDeptAP(Department dept) {
    string aps[] = {"MGMT-AP1", "IT-AP1", "SALES-AP1", "FIN-AP1", "HR-AP1"};
    return dept <= HR ? aps[dept] : "";
}

// Initialize DHCP Pools
void initializeDHCPPools() {
    dhcpPools["MGMT-POOL"] = {"Management Pool", "10.10.10.0/24", "VLAN10", 20, 100, 20, {}};
    dhcpPools["IT-POOL"] = {"IT Pool", "10.10.20.0/24", "VLAN20", 20, 100, 20, {}};
    dhcpPools["SALES-POOL"] = {"Sales Pool", "10.10.30.0/24", "VLAN30", 20, 100, 20, {}};
    dhcpPools["FIN-POOL"] = {"Finance Pool", "10.10.40.0/24", "VLAN40", 20, 100, 20, {}};
    dhcpPools["HR-POOL"] = {"HR Pool", "10.10.50.0/24", "VLAN50", 20, 100, 20, {}};
    dhcpPools["VOICE-POOL"] = {"Voice Pool", "10.10.60.0/24", "VLAN60", 10, 50, 10, {}};
    dhcpPools["WIRELESS-POOL"] = {"Wireless Pool", "10.10.70.0/24", "VLAN70", 20, 100, 20, {}};
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL SERVICE STATUS - ADD AFTER dhcpPools declaration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•



ServiceStatus globalServices = {true, true, true, "MGMT-SRV1", "MGMT-SRV1", "MGMT-SRV1"};
// Initialize Email Directory
void initializeEmailDirectory() {
    emailDirectory["ceo@cloudtap.pk"] = "Operations Manager (Management)";
    emailDirectory["it.admin@cloudtap.pk"] = "IT Administrator (IT)";
    emailDirectory["sales.manager@cloudtap.pk"] = "Sales Manager (Sales)";
    emailDirectory["finance.manager@cloudtap.pk"] = "Finance Manager (Finance)";
    emailDirectory["hr.manager@cloudtap.pk"] = "HR Manager (HR)";
}

// Initialize Phone Directory
void initializePhoneDirectory() {
    phoneDirectory["0001"] = "Operations Manager (Management)";
    phoneDirectory["0002"] = "IT Administrator (IT)";
    phoneDirectory["0003"] = "Sales Manager (Sales)";
    phoneDirectory["0004"] = "Finance Manager (Finance)";
    phoneDirectory["0005"] = "HR Manager (HR)";
}

// Initialize Sample Emails
void initializeSampleEmails() {
    emailInbox.push_back({"system@cloudtap.pk", "ceo@cloudtap.pk", "System Alert: Network Status",
                          "Network initialization complete. All systems operational.", getCurrentTime(), false});
    emailInbox.push_back({"it.admin@cloudtap.pk", "ceo@cloudtap.pk", "Weekly Network Report",
                          "Total devices: 48 | Active links: 75 | System uptime: 99.9%", getCurrentTime(), false});
    emailInbox.push_back({"sales.manager@cloudtap.pk", "ceo@cloudtap.pk", "Department Update",
                          "Sales department network expansion complete. 3 new devices added.", getCurrentTime(), false});
}

// Get IP from DHCP Pool
// Get IP from DHCP Pool
string getIPFromDHCP(string poolName) {
    if (dhcpPools.find(poolName) == dhcpPools.end()) return "";
    
    DHCPPool& pool = dhcpPools[poolName];
    while (pool.currentIP <= pool.endIP) {
        if (pool.usedIPs.find(pool.currentIP) == pool.usedIPs.end()) {
            pool.usedIPs.insert(pool.currentIP);
            string subnet = pool.subnet.substr(0, pool.subnet.find("/"));
            string baseIP = subnet.substr(0, subnet.rfind('.') + 1);
            string assignedIP = baseIP + to_string(pool.currentIP++);  // â¬…ï¸ DECLARE HERE
            
            // â¬…ï¸ ADD DHCP LOGGING (after assignedIP is declared)
            logToSyslog(INFO, DHCP_SERVER, "MGMT-SRV1", "10.10.10.10",
                       "DHCP_LEASE_ASSIGNED",
                       "IP " + assignedIP + " assigned from pool " + poolName +
                       " | VLAN: " + pool.vlan, "dhcp_server");
            
            return assignedIP;
        }
        pool.currentIP++;
    }
    
    // â¬…ï¸ ADD ERROR LOGGING IF POOL EXHAUSTED
    logToSyslog(ERROR, DHCP_SERVER, "MGMT-SRV1", "10.10.10.10",
               "DHCP_POOL_EXHAUSTED",
               "Pool " + poolName + " has no available IPs! Pool size: " +
               to_string(pool.getTotalCount()), "dhcp_server");
    
    return "";
}
string getDHCPPoolName(Department dept, DeviceType type) {
    if (type == EPHONE) return "VOICE-POOL";
    if (type == PHONE || type == TABLET) return "WIRELESS-POOL";
    string pools[] = {"MGMT-POOL", "IT-POOL", "SALES-POOL", "FIN-POOL", "HR-POOL"};
    return dept <= HR ? pools[dept] : "";
}

// Initialize Complete Network (48 Devices)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZE NETWORK - COMPLETE REPLACEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK TOOLS HELPER FUNCTIONS - ADD BEFORE initializeNetwork()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Generate MAC Address from Device ID
string generateMAC(const string& deviceId) {
    uint64_t hash = 0;  // â¬…ï¸ FIXED: Use 64-bit
    for (char c : deviceId) {
       hash = (hash * 31 + static_cast<unsigned char>(c)) % UINT64_MAX;  // â¬…ï¸ FIXED
    }
    
    char mac[18];
    snprintf(mac, sizeof(mac), "00:1A:%02X:%02X:%02X:%02X",  // â¬…ï¸ FIXED
            (hash >> 24) & 0xFF,
            (hash >> 16) & 0xFF,
            (hash >> 8) & 0xFF,
            hash & 0xFF);
    return string(mac);
}

// Get Default Gateway based on VLAN
string getDefaultGateway(const Device& dev) {
    if (dev.vlan == "VLAN10") return "10.10.10.254";
    if (dev.vlan == "VLAN20") return "10.10.20.254";
    if (dev.vlan == "VLAN30") return "10.10.30.254";
    if (dev.vlan == "VLAN40") return "10.10.40.254";
    if (dev.vlan == "VLAN50") return "10.10.50.254";
    if (dev.vlan == "VLAN60") return "10.10.60.254";
    if (dev.vlan == "VLAN70") return "10.10.70.254";
    return "192.168.1.1";
}

// Initialize ARP Tables for all devices
void initializeARPTables() {
    for (auto& pair : networkDevices) {
        Device& dev = pair.second;
        string devId = dev.id;
        
        // Add ARP entries for directly connected devices
        for (const Connection& conn : dev.connections) {
            if (networkDevices.find(conn.targetDevice) != networkDevices.end()) {
                Device& target = networkDevices[conn.targetDevice];
                
                ARPEntry entry;
                entry.ipAddress = target.ipAddress;
                entry.macAddress = target.macAddress;
                entry.type = "dynamic";
                entry.interfaceName = "Ethernet0";
                entry.timestamp = time(0);
                entry.ttl = 300;
                
                deviceARPTables[devId].push_back(entry);
            }
        }
    }
}

// Simulate Active Connections for Netstat
void simulateActiveConnections(Device& dev) {
    dev.activeConnections.clear();
    
    for (const Connection& conn : dev.connections) {
        if (networkDevices.find(conn.targetDevice) != networkDevices.end()) {
            Device& target = networkDevices[conn.targetDevice];
            
            ConnectionState state;
            state.protocol = "TCP";
            state.localAddress = dev.ipAddress;
            state.localPort = 49152 + (rand() % 1000);
            state.remoteAddress = target.ipAddress;
            
            if (target.type == SERVER) {
                state.remotePort = 80;
            } else {
                state.remotePort = 49152 + (rand() % 1000);
            }
            
            state.state = "ESTABLISHED";
            state.pid = 1000 + (rand() % 9000);
            state.processName = "network.exe";
            state.timestamp = getCurrentTime();
            
            dev.activeConnections.push_back(state);
        }
    }
}

// Find path between two devices (for Traceroute)
vector<string> findPath(const string& startId, const string& endIP) {
    vector<string> path;
    set<string> visited;
    queue<pair<string, vector<string>>> q;
    
    q.push({startId, {startId}});
    visited.insert(startId);
    
    string targetId;
    for (auto& pair : networkDevices) {
        if (pair.second.ipAddress == endIP) {
            targetId = pair.first;
            break;
        }
    }
    
    if (targetId.empty()) return path;
    
    while (!q.empty()) {
        auto current = q.front();
        q.pop();
        
        string currentId = current.first;
        vector<string> currentPath = current.second;
        
        if (currentId == targetId) {
            return currentPath;
        }
        
        if (networkDevices.find(currentId) != networkDevices.end()) {
            for (const Connection& conn : networkDevices[currentId].connections) {
                if (visited.find(conn.targetDevice) == visited.end()) {
                    visited.insert(conn.targetDevice);
                    vector<string> newPath = currentPath;
                    newPath.push_back(conn.targetDevice);
                    q.push({conn.targetDevice, newPath});
                }
            }
        }
    }
    
    return path;
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZE ROUTING TABLES - ADD BEFORE initializeNetwork()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initializeRoutingTables() {
    // ========== CORE-R1 (Core Router) ==========
    networkDevices["CORE-R1"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "192.168.100.1", "GigabitEthernet0/1", 1, "Static", true},  // Default to FW
        {"10.10.0.0/16", "255.255.0.0", "10.10.0.1", "GigabitEthernet0/0", 1, "OSPF", true}, // To L3 switches
        {"192.168.1.0/24", "255.255.255.0", "0.0.0.0", "GigabitEthernet0/0", 0, "Connected", true}
    };
    
    // ========== L3-ACTIVE (L3 Core Switch - Active) ==========
    networkDevices["L3-ACTIVE"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "192.168.1.1", "GigabitEthernet0/0", 1, "Static", true},  // Default to Core
        {"10.10.10.0/24", "255.255.255.0", "0.0.0.0", "Vlan10", 0, "Connected", true},  // Management VLAN
        {"10.10.20.0/24", "255.255.255.0", "0.0.0.0", "Vlan20", 0, "Connected", true},  // IT VLAN
        {"10.10.30.0/24", "255.255.255.0", "0.0.0.0", "Vlan30", 0, "Connected", true},  // Sales VLAN
        {"10.10.40.0/24", "255.255.255.0", "0.0.0.0", "Vlan40", 0, "Connected", true},  // Finance VLAN
        {"10.10.50.0/24", "255.255.255.0", "0.0.0.0", "Vlan50", 0, "Connected", true},  // HR VLAN
        {"10.10.60.0/24", "255.255.255.0", "10.10.60.254", "GigabitEthernet0/1", 1, "Static", true},  // Voice VLAN
        {"10.10.70.0/24", "255.255.255.0", "10.10.70.254", "GigabitEthernet0/2", 1, "Static", true},  // Wireless VLAN
        {"192.168.1.0/24", "255.255.255.0", "192.168.1.1", "GigabitEthernet0/0", 1, "OSPF", true}
    };
    
    // ========== L3-STANDBY (L3 Core Switch - Standby) ==========
    networkDevices["L3-STANDBY"].routingTable = networkDevices["L3-ACTIVE"].routingTable;  // Same routes
    
    // ========== VOICE-R1 (Voice Router) ==========
    networkDevices["VOICE-R1"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "10.10.0.1", "GigabitEthernet0/0", 1, "Static", true},  // Default to L3-ACTIVE
        {"10.10.60.0/24", "255.255.255.0", "0.0.0.0", "GigabitEthernet0/1", 0, "Connected", true}  // Voice VLAN
    };
    
    // ========== WLC-1 (Wireless LAN Controller) ==========
    networkDevices["WLC-1"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "10.10.0.1", "GigabitEthernet0/0", 1, "Static", true},  // Default to L3-ACTIVE
        {"10.10.70.0/24", "255.255.255.0", "0.0.0.0", "GigabitEthernet0/1", 0, "Connected", true}  // Wireless VLAN
    };
    
    // ========== FW-1 (Firewall) ==========
    networkDevices["FW-1"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "203.0.113.1", "outside", 1, "Static", true},  // Default to ISP
        {"10.10.0.0/16", "255.255.0.0", "192.168.1.1", "inside", 1, "Static", true},  // To Core Router
        {"172.16.0.0/24", "255.255.255.0", "172.16.0.1", "dmz", 1, "Static", true},  // To DMZ
        {"192.168.1.0/24", "255.255.255.0", "192.168.1.1", "inside", 1, "Static", true},
        {"192.168.100.0/24", "255.255.255.0", "0.0.0.0", "inside", 0, "Connected", true}
    };
    networkDevices["FW-1"].natEnabled = true;  // Enable NAT
    
    // ========== ISP-R1 (ISP Router) ==========
    networkDevices["ISP-R1"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "8.8.8.1", "GigabitEthernet0/1", 1, "Static", true},  // Default to Internet
        {"192.168.100.0/24", "255.255.255.0", "192.168.100.1", "GigabitEthernet0/0", 1, "Static", true},  // To Firewall
        {"203.0.113.0/30", "255.255.255.252", "0.0.0.0", "GigabitEthernet0/0", 0, "Connected", true}
    };
    
    // ========== DMZ-L3 (DMZ L3 Switch) ==========
    networkDevices["DMZ-L3"].routingTable = {
        {"0.0.0.0/0", "0.0.0.0", "192.168.100.1", "GigabitEthernet0/0", 1, "Static", true},  // Default to FW
        {"172.16.0.0/24", "255.255.255.0", "0.0.0.0", "Vlan1", 0, "Connected", true}  // DMZ subnet
    };
    
    // ========== EXT-R1 (External Router) ==========
    networkDevices["EXT-R1"].routingTable = {
        {"8.8.8.0/24", "255.255.255.0", "0.0.0.0", "GigabitEthernet0/1", 0, "Connected", true},  // Google subnet
        {"203.0.113.0/30", "255.255.255.252", "203.0.113.1", "GigabitEthernet0/0", 1, "Static", true}
    };
    
    logToSyslog(INFO, SYSTEM, "CORE-R1", "192.168.1.1",
               "ROUTING_TABLES_INITIALIZED",
               "All routing tables initialized | Protocols: Static + OSPF", "system");
}

void initializeVLANs() {
    // L3-ACTIVE VLANs
    networkDevices["L3-ACTIVE"].vlans = {
        {10, "Management", "10.10.10.0/24", {"Gi0/10", "Gi0/11"}, true},
        {20, "IT", "10.10.20.0/24", {"Gi0/20", "Gi0/21"}, true},
        {30, "Sales", "10.10.30.0/24", {"Gi0/30", "Gi0/31"}, true},
        {40, "Finance", "10.10.40.0/24", {"Gi0/40", "Gi0/41"}, true},
        {50, "HR", "10.10.50.0/24", {"Gi0/50", "Gi0/51"}, true},
        {60, "Voice", "10.10.60.0/24", {}, true},
        {70, "Wireless", "10.10.70.0/24", {}, true}
    };
    
    // L3-STANDBY VLANs (same as active)
    networkDevices["L3-STANDBY"].vlans = networkDevices["L3-ACTIVE"].vlans;
    
    // Department L2 Switches
    networkDevices["MGMT-SW1"].vlans = {{10, "Management", "10.10.10.0/24", {}, true}};
    networkDevices["IT-SW1"].vlans = {{20, "IT", "10.10.20.0/24", {}, true}};
    networkDevices["SALES-SW1"].vlans = {{30, "Sales", "10.10.30.0/24", {}, true}};
    networkDevices["FIN-SW1"].vlans = {{40, "Finance", "10.10.40.0/24", {}, true}};
    networkDevices["HR-SW1"].vlans = {{50, "HR", "10.10.50.0/24", {}, true}};
    
    logToSyslog(INFO, SYSTEM, "L3-ACTIVE", "10.10.0.1",
               "VLAN_CONFIGURATION_LOADED",
               "7 VLANs configured | ID: 10,20,30,40,50,60,70", "system");
}

void initializeTrunkLinks() {
    globalTrunkLinks = {
        {"L3-ACTIVE", "Gi0/1", "L3-STANDBY", "Gi0/1", {10,20,30,40,50,60,70}, "802.1Q", true},
        {"L3-ACTIVE", "Gi0/10", "MGMT-SW1", "Gi0/1", {10}, "802.1Q", true},
        {"L3-ACTIVE", "Gi0/20", "IT-SW1", "Gi0/1", {20}, "802.1Q", true},
        {"L3-ACTIVE", "Gi0/30", "SALES-SW1", "Gi0/1", {30}, "802.1Q", true},
        {"L3-ACTIVE", "Gi0/40", "FIN-SW1", "Gi0/1", {40}, "802.1Q", true},
        {"L3-ACTIVE", "Gi0/50", "HR-SW1", "Gi0/1", {50}, "802.1Q", true},
        {"L3-STANDBY", "Gi0/10", "MGMT-SW1", "Gi0/2", {10}, "802.1Q", true},
        {"L3-STANDBY", "Gi0/20", "IT-SW1", "Gi0/2", {20}, "802.1Q", true},
        {"L3-STANDBY", "Gi0/30", "SALES-SW1", "Gi0/2", {30}, "802.1Q", true},
        {"L3-STANDBY", "Gi0/40", "FIN-SW1", "Gi0/2", {40}, "802.1Q", true},
        {"L3-STANDBY", "Gi0/50", "HR-SW1", "Gi0/2", {50}, "802.1Q", true}
    };
    
    // Assign trunks to devices
    for (const TrunkLink& trunk : globalTrunkLinks) {
        networkDevices[trunk.localDevice].trunks.push_back(trunk);
    }
}

void initializeOSPF() {
    // CORE-R1 OSPF Neighbors
    networkDevices["CORE-R1"].ospfNeighbors = {
        {"10.10.0.1", "10.10.0.1", "Gi0/0", "FULL", 1, "00:00:35"},  // L3-ACTIVE
        {"10.10.0.2", "10.10.0.2", "Gi0/0", "FULL", 1, "00:00:33"}   // L3-STANDBY
    };
    
    // L3-ACTIVE OSPF Neighbors
    networkDevices["L3-ACTIVE"].ospfNeighbors = {
        {"192.168.1.1", "192.168.1.1", "Gi0/0", "FULL", 1, "00:00:37"}  // CORE-R1
    };
    
    // L3-STANDBY OSPF Neighbors
    networkDevices["L3-STANDBY"].ospfNeighbors = {
        {"192.168.1.1", "192.168.1.1", "Gi0/0", "FULL", 1, "00:00:36"}  // CORE-R1
    };
}

void initializeHSRP() {
    // L3-ACTIVE (HSRP Active)
    networkDevices["L3-ACTIVE"].hsrpStatus = {
        "L3-ACTIVE", 1, "10.10.0.254", "Active", 110, "Enabled"
    };
    
    // L3-STANDBY (HSRP Standby)
    networkDevices["L3-STANDBY"].hsrpStatus = {
        "L3-STANDBY", 1, "10.10.0.254", "Standby", 100, "Enabled"
    };
}
void initializeNetwork() {
    // INTERNET ZONE
    networkDevices["GOOGLE-SRV"] = {"GOOGLE-SRV", "Google Server", "8.8.8.8", "8.8.8.0/24", "-", "Internet", SERVER, {}, true, false, ONLINE, "", "", false};
    networkDevices["EXT-L2"] = {"EXT-L2", "External L2 Switch", "8.8.8.254", "8.8.8.0/24", "-", "Internet", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["EXT-R1"] = {"EXT-R1", "External Router", "8.8.8.1", "8.8.8.0/24", "-", "Internet", ROUTER, {}, true, false, ONLINE, "", "", false};
    networkDevices["ISP-R1"] = {"ISP-R1", "ISP Router", "203.0.113.1", "203.0.113.0/30", "-", "Internet", ROUTER, {}, true, false, ONLINE, "", "", false};
    
    // SECURITY ZONE
    networkDevices["FW-1"] = {"FW-1", "Firewall", "192.168.100.1", "192.168.100.0/24", "-", "Security", FIREWALL, {}, true, false, ONLINE, "", "", false};
    
    // DMZ ZONE
    networkDevices["DMZ-L3"] = {"DMZ-L3", "DMZ L3 Switch", "172.16.0.1", "172.16.0.0/24", "-", "DMZ", L3_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["DMZ-SRV"] = {"DMZ-SRV", "DMZ Server", "172.16.0.10", "172.16.0.0/24", "-", "DMZ", SERVER, {}, true, false, ONLINE, "", "", false};
    
    // CORE INFRASTRUCTURE
    networkDevices["CORE-R1"] = {"CORE-R1", "Core Router", "192.168.1.1", "192.168.1.0/24", "-", "Core", ROUTER, {}, true, false, ONLINE, "", "", false};
    networkDevices["L3-ACTIVE"] = {"L3-ACTIVE", "L3 Core Switch (Active)", "10.10.0.1", "10.10.0.0/24", "ALL", "Core", L3_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["L3-STANDBY"] = {"L3-STANDBY", "L3 Core Switch (Standby)", "10.10.0.2", "10.10.0.0/24", "ALL", "Core", L3_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["VOICE-R1"] = {"VOICE-R1", "Voice Router", "10.10.60.254", "10.10.60.0/24", "VLAN60", "Voice", ROUTER, {}, true, false, ONLINE, "", "", false};
    networkDevices["WLC-1"] = {"WLC-1", "Wireless LAN Controller", "10.10.70.254", "10.10.70.0/24", "VLAN70", "Wireless", WLC, {}, true, false, ONLINE, "", "", false};
    
    // MANAGEMENT DEPARTMENT (7 devices)
    networkDevices["MGMT-SW1"] = {"MGMT-SW1", "L2 Switch Management", "10.10.10.254", "10.10.10.0/24", "VLAN10", "Management", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-SRV1"] = {"MGMT-SRV1", "DHCP/Email/Web Server", "10.10.10.10", "10.10.10.0/24", "VLAN10", "Management", SERVER, {}, true, false, ONLINE, "", "", true};  // â¬…ï¸ TRUE for critical
    networkDevices["MGMT-AP1"] = {"MGMT-AP1", "AP-MGT", "10.10.70.1", "10.10.70.0/24", "VLAN70", "Management", ACCESS_POINT, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-EP1"] = {"MGMT-EP1", "ePhone 0001", "10.10.60.1", "10.10.60.0/24", "VLAN60", "Management", EPHONE, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-PC1"] = {"MGMT-PC1", "PC Operations Manager", "10.10.10.1", "10.10.10.0/24", "VLAN10", "Management", PC, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-LAP1"] = {"MGMT-LAP1", "Laptop CEO", "10.10.10.2", "10.10.10.0/24", "VLAN10", "Management", LAPTOP, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-TAB1"] = {"MGMT-TAB1", "Tablet Coordinator", "10.10.70.2", "10.10.70.0/24", "VLAN70", "Management", TABLET, {}, true, false, ONLINE, "", "", false};
    networkDevices["MGMT-PHN1"] = {"MGMT-PHN1", "Phone Assistant", "10.10.70.3", "10.10.70.0/24", "VLAN70", "Management", PHONE, {}, true, false, ONLINE, "", "", false};
    
    // IT DEPARTMENT (7 devices)
    networkDevices["IT-SW1"] = {"IT-SW1", "L2 Switch IT", "10.10.20.254", "10.10.20.0/24", "VLAN20", "IT", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-AP1"] = {"IT-AP1", "AP-IT", "10.10.70.4", "10.10.70.0/24", "VLAN70", "IT", ACCESS_POINT, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-EP1"] = {"IT-EP1", "ePhone 0002", "10.10.60.2", "10.10.60.0/24", "VLAN60", "IT", EPHONE, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-PC1"] = {"IT-PC1", "PC IT Admin", "10.10.20.1", "10.10.20.0/24", "VLAN20", "IT", PC, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-LAP1"] = {"IT-LAP1", "Laptop Jr Developer", "10.10.20.2", "10.10.20.0/24", "VLAN20", "IT", LAPTOP, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-TAB1"] = {"IT-TAB1", "Tablet SysAdmin", "10.10.70.5", "10.10.70.0/24", "VLAN70", "IT", TABLET, {}, true, false, ONLINE, "", "", false};
    networkDevices["IT-PHN1"] = {"IT-PHN1", "Phone Network Engineer", "10.10.70.6", "10.10.70.0/24", "VLAN70", "IT", PHONE, {}, true, false, ONLINE, "", "", false};
    
    // SALES DEPARTMENT (7 devices)
    networkDevices["SALES-SW1"] = {"SALES-SW1", "L2 Switch Sales", "10.10.30.254", "10.10.30.0/24", "VLAN30", "Sales", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-AP1"] = {"SALES-AP1", "AP-SALES", "10.10.70.7", "10.10.70.0/24", "VLAN70", "Sales", ACCESS_POINT, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-EP1"] = {"SALES-EP1", "ePhone 0003", "10.10.60.3", "10.10.60.0/24", "VLAN60", "Sales", EPHONE, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-PC1"] = {"SALES-PC1", "PC Sales Manager", "10.10.30.1", "10.10.30.0/24", "VLAN30", "Sales", PC, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-LAP1"] = {"SALES-LAP1", "Laptop Market Analyst", "10.10.30.2", "10.10.30.0/24", "VLAN30", "Sales", LAPTOP, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-TAB1"] = {"SALES-TAB1", "Tablet Business Developer", "10.10.70.8", "10.10.70.0/24", "VLAN70", "Sales", TABLET, {}, true, false, ONLINE, "", "", false};
    networkDevices["SALES-PHN1"] = {"SALES-PHN1", "Phone Sales Executive", "10.10.70.9", "10.10.70.0/24", "VLAN70", "Sales", PHONE, {}, true, false, ONLINE, "", "", false};
    
    // FINANCE DEPARTMENT (7 devices)
    networkDevices["FIN-SW1"] = {"FIN-SW1", "L2 Switch Finance", "10.10.40.254", "10.10.40.0/24", "VLAN40", "Finance", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-AP1"] = {"FIN-AP1", "AP-FIN", "10.10.70.10", "10.10.70.0/24", "VLAN70", "Finance", ACCESS_POINT, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-EP1"] = {"FIN-EP1", "ePhone 0004", "10.10.60.4", "10.10.60.0/24", "VLAN60", "Finance", EPHONE, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-PC1"] = {"FIN-PC1", "PC Finance Manager", "10.10.40.1", "10.10.40.0/24", "VLAN40", "Finance", PC, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-LAP1"] = {"FIN-LAP1", "Laptop Sr Accountant", "10.10.40.2", "10.10.40.0/24", "VLAN40", "Finance", LAPTOP, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-TAB1"] = {"FIN-TAB1", "Tablet Financial Analyst", "10.10.70.11", "10.10.70.0/24", "VLAN70", "Finance", TABLET, {}, true, false, ONLINE, "", "", false};
    networkDevices["FIN-PHN1"] = {"FIN-PHN1", "Phone Jr Accountant", "10.10.70.12", "10.10.70.0/24", "VLAN70", "Finance", PHONE, {}, true, false, ONLINE, "", "", false};
    
    // HR DEPARTMENT (7 devices)
    networkDevices["HR-SW1"] = {"HR-SW1", "L2 Switch HR", "10.10.50.254", "10.10.50.0/24", "VLAN50", "HR", L2_SWITCH, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-AP1"] = {"HR-AP1", "AP-HR", "10.10.70.13", "10.10.70.0/24", "VLAN70", "HR", ACCESS_POINT, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-EP1"] = {"HR-EP1", "ePhone 0005", "10.10.60.5", "10.10.60.0/24", "VLAN60", "HR", EPHONE, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-PC1"] = {"HR-PC1", "PC HR Manager", "10.10.50.1", "10.10.50.0/24", "VLAN50", "HR", PC, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-LAP1"] = {"HR-LAP1", "Laptop HR Recruiter", "10.10.50.2", "10.10.50.0/24", "VLAN50", "HR", LAPTOP, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-TAB1"] = {"HR-TAB1", "Tablet Training Specialist", "10.10.70.14", "10.10.70.0/24", "VLAN70", "HR", TABLET, {}, true, false, ONLINE, "", "", false};
    networkDevices["HR-PHN1"] = {"HR-PHN1", "Phone HR Coordinator", "10.10.70.15", "10.10.70.0/24", "VLAN70", "HR", PHONE, {}, true, false, ONLINE, "", "", false};
    
    // Mark pre-assigned IPs in DHCP pools
    for (auto& pair : networkDevices) {
        Device& dev = pair.second;
        string poolName = "";
        
        if (dev.vlan == "VLAN10") poolName = "MGMT-POOL";
        else if (dev.vlan == "VLAN20") poolName = "IT-POOL";
        else if (dev.vlan == "VLAN30") poolName = "SALES-POOL";
        else if (dev.vlan == "VLAN40") poolName = "FIN-POOL";
        else if (dev.vlan == "VLAN50") poolName = "HR-POOL";
        else if (dev.vlan == "VLAN60") poolName = "VOICE-POOL";
        else if (dev.vlan == "VLAN70") poolName = "WIRELESS-POOL";
        
        if (!poolName.empty() && dhcpPools.find(poolName) != dhcpPools.end()) {
            int lastOctet = stoi(dev.ipAddress.substr(dev.ipAddress.rfind('.') + 1));
            dhcpPools[poolName].usedIPs.insert(lastOctet);
        }
    }
    
    totalDevices = networkDevices.size();
    totalConnections = 75;
    
    logToSyslog(NOTICE, SYSTEM, "CORE-R1", "192.168.1.1",
               "SYSTEM_INIT",
               "Network initialized | Devices: " + to_string(totalDevices) +
               " | Links: " + to_string(totalConnections), "system");
               // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INITIALIZE NETWORK INTERFACES & ARP TABLES - ADD AT END OF initializeNetwork()
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    for (auto& pair : networkDevices) {
        Device& dev = pair.second;
        
        // Generate MAC address
        dev.macAddress = generateMAC(dev.id);
        
        // Create primary interface
        NetworkInterface eth0;
        eth0.interfaceName = (dev.type == ROUTER || dev.type == L3_SWITCH) ? 
                            "GigabitEthernet0/0" : "Ethernet0";
        eth0.macAddress = dev.macAddress;
        eth0.ipAddress = dev.ipAddress;
        eth0.subnetMask = "255.255.255.0";
        eth0.defaultGateway = getDefaultGateway(dev);
        eth0.dnsServer = "10.10.10.10";
        eth0.dhcpEnabled = dev.isDHCP;
        eth0.dhcpServer = dev.isDHCP ? "10.10.10.10" : "";
        eth0.mtu = 1500;
        eth0.bytesReceived = rand() % 10000000;
        eth0.bytesSent = rand() % 10000000;
        eth0.packetsReceived = rand() % 100000;
        eth0.packetsSent = rand() % 100000;
        eth0.interfaceStatus = dev.status == ONLINE ? "UP" : "DOWN";
        
        dev.interfaces.push_back(eth0);
        
        // Initialize listening ports for servers
        if (dev.type == SERVER) {
            dev.listeningPorts.push_back({80, "TCP", "HTTP", "0.0.0.0", true});
            dev.listeningPorts.push_back({443, "TCP", "HTTPS", "0.0.0.0", true});
            dev.listeningPorts.push_back({25, "TCP", "SMTP", "0.0.0.0", true});
            dev.listeningPorts.push_back({110, "TCP", "POP3", "0.0.0.0", true});
            dev.listeningPorts.push_back({143, "TCP", "IMAP", "0.0.0.0", true});
            dev.listeningPorts.push_back({67, "UDP", "DHCP-Server", "0.0.0.0", true});
            dev.listeningPorts.push_back({53, "UDP", "DNS", "0.0.0.0", true});
        }
        
        // Routers and switches have SSH
        if (dev.type == ROUTER || dev.type == L3_SWITCH || dev.type == L2_SWITCH) {
            dev.listeningPorts.push_back({22, "TCP", "SSH", "0.0.0.0", true});
            dev.listeningPorts.push_back({23, "TCP", "Telnet", "0.0.0.0", false});
        }
        
        // PCs and Laptops have RDP
        if (dev.type == PC || dev.type == LAPTOP) {
            dev.listeningPorts.push_back({3389, "TCP", "RDP", "0.0.0.0", true});
            dev.listeningPorts.push_back({445, "TCP", "SMB", "0.0.0.0", true});
        }
    }
    
    // Initialize ARP tables
    initializeARPTables();
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INITIALIZE ROUTING & SWITCHING - ADD AT END OF initializeNetwork()
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    initializeRoutingTables();
    initializeVLANs();
    initializeTrunkLinks();
    initializeOSPF();
    initializeHSRP();
    
    logToSyslog(NOTICE, SYSTEM, "CORE-R1", "192.168.1.1",
               "ROUTING_PROTOCOLS_ACTIVE",
               "OSPF + HSRP + Static routes configured", "system");
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZE ALL CONNECTIONS - ADD AFTER initializeNetwork()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void initializeConnections() {
    // ========== CORE INFRASTRUCTURE ==========
    
    // Core Router connections
    networkDevices["CORE-R1"].connections.push_back({"L3-ACTIVE", "OSPF"});
    networkDevices["CORE-R1"].connections.push_back({"L3-STANDBY", "OSPF"});
    networkDevices["CORE-R1"].connections.push_back({"FW-1", "Routing"});
    
    // L3-ACTIVE connections (bidirectional)
    networkDevices["L3-ACTIVE"].connections.push_back({"CORE-R1", "OSPF"});
    networkDevices["L3-ACTIVE"].connections.push_back({"L3-STANDBY", "HSRP+LACP"});
    networkDevices["L3-ACTIVE"].connections.push_back({"VOICE-R1", "Routing"});
    networkDevices["L3-ACTIVE"].connections.push_back({"WLC-1", "Management"});
    networkDevices["L3-ACTIVE"].connections.push_back({"MGMT-SW1", "Trunk"});
    networkDevices["L3-ACTIVE"].connections.push_back({"IT-SW1", "Trunk"});
    networkDevices["L3-ACTIVE"].connections.push_back({"SALES-SW1", "Trunk"});
    networkDevices["L3-ACTIVE"].connections.push_back({"FIN-SW1", "Trunk"});
    networkDevices["L3-ACTIVE"].connections.push_back({"HR-SW1", "Trunk"});
    
    // L3-STANDBY connections
    networkDevices["L3-STANDBY"].connections.push_back({"CORE-R1", "OSPF"});
    networkDevices["L3-STANDBY"].connections.push_back({"L3-ACTIVE", "HSRP+LACP"});
    networkDevices["L3-STANDBY"].connections.push_back({"MGMT-SW1", "Trunk"});
    networkDevices["L3-STANDBY"].connections.push_back({"IT-SW1", "Trunk"});
    networkDevices["L3-STANDBY"].connections.push_back({"SALES-SW1", "Trunk"});
    networkDevices["L3-STANDBY"].connections.push_back({"FIN-SW1", "Trunk"});
    networkDevices["L3-STANDBY"].connections.push_back({"HR-SW1", "Trunk"});
    
    // Voice Router
    networkDevices["VOICE-R1"].connections.push_back({"L3-ACTIVE", "Routing"});
    
    // WLC
    networkDevices["WLC-1"].connections.push_back({"L3-ACTIVE", "Management"});
    
    // ========== MANAGEMENT DEPARTMENT ==========
    
    networkDevices["MGMT-SW1"].connections.push_back({"L3-ACTIVE", "Trunk"});
    networkDevices["MGMT-SW1"].connections.push_back({"L3-STANDBY", "Trunk"});
    networkDevices["MGMT-SW1"].connections.push_back({"MGMT-EP1", "Access"});
    networkDevices["MGMT-SW1"].connections.push_back({"MGMT-SRV1", "Access"});
    networkDevices["MGMT-SW1"].connections.push_back({"MGMT-LAP1", "Access"});
    networkDevices["MGMT-SW1"].connections.push_back({"MGMT-AP1", "Access"});
    
    networkDevices["MGMT-EP1"].connections.push_back({"MGMT-SW1", "Access"});
    networkDevices["MGMT-EP1"].connections.push_back({"MGMT-PC1", "Passthrough"});
    
    networkDevices["MGMT-PC1"].connections.push_back({"MGMT-EP1", "Passthrough"});
    
    networkDevices["MGMT-SRV1"].connections.push_back({"MGMT-SW1", "Access"});
    networkDevices["MGMT-LAP1"].connections.push_back({"MGMT-SW1", "Access"});
    
    networkDevices["MGMT-AP1"].connections.push_back({"MGMT-SW1", "Access"});
    networkDevices["MGMT-AP1"].connections.push_back({"MGMT-TAB1", "Wireless"});
    networkDevices["MGMT-AP1"].connections.push_back({"MGMT-PHN1", "Wireless"});
    
    networkDevices["MGMT-TAB1"].connections.push_back({"MGMT-AP1", "Wireless"});
    networkDevices["MGMT-PHN1"].connections.push_back({"MGMT-AP1", "Wireless"});
    
    // ========== IT DEPARTMENT ==========
    
    networkDevices["IT-SW1"].connections.push_back({"L3-ACTIVE", "Trunk"});
    networkDevices["IT-SW1"].connections.push_back({"L3-STANDBY", "Trunk"});
    networkDevices["IT-SW1"].connections.push_back({"IT-EP1", "Access"});
    networkDevices["IT-SW1"].connections.push_back({"IT-LAP1", "Access"});
    networkDevices["IT-SW1"].connections.push_back({"IT-AP1", "Access"});
    
    networkDevices["IT-EP1"].connections.push_back({"IT-SW1", "Access"});
    networkDevices["IT-EP1"].connections.push_back({"IT-PC1", "Passthrough"});
    
    networkDevices["IT-PC1"].connections.push_back({"IT-EP1", "Passthrough"});
    
    networkDevices["IT-LAP1"].connections.push_back({"IT-SW1", "Access"});
    
    networkDevices["IT-AP1"].connections.push_back({"IT-SW1", "Access"});
    networkDevices["IT-AP1"].connections.push_back({"IT-TAB1", "Wireless"});
    networkDevices["IT-AP1"].connections.push_back({"IT-PHN1", "Wireless"});
    
    networkDevices["IT-TAB1"].connections.push_back({"IT-AP1", "Wireless"});
    networkDevices["IT-PHN1"].connections.push_back({"IT-AP1", "Wireless"});
    
    // ========== SALES DEPARTMENT ==========
    
    networkDevices["SALES-SW1"].connections.push_back({"L3-ACTIVE", "Trunk"});
    networkDevices["SALES-SW1"].connections.push_back({"L3-STANDBY", "Trunk"});
    networkDevices["SALES-SW1"].connections.push_back({"SALES-EP1", "Access"});
    networkDevices["SALES-SW1"].connections.push_back({"SALES-LAP1", "Access"});
    networkDevices["SALES-SW1"].connections.push_back({"SALES-AP1", "Access"});
    
    networkDevices["SALES-EP1"].connections.push_back({"SALES-SW1", "Access"});
    networkDevices["SALES-EP1"].connections.push_back({"SALES-PC1", "Passthrough"});
    
    networkDevices["SALES-PC1"].connections.push_back({"SALES-EP1", "Passthrough"});
    
    networkDevices["SALES-LAP1"].connections.push_back({"SALES-SW1", "Access"});
    
    networkDevices["SALES-AP1"].connections.push_back({"SALES-SW1", "Access"});
    networkDevices["SALES-AP1"].connections.push_back({"SALES-TAB1", "Wireless"});
    networkDevices["SALES-AP1"].connections.push_back({"SALES-PHN1", "Wireless"});
    
    networkDevices["SALES-TAB1"].connections.push_back({"SALES-AP1", "Wireless"});
    networkDevices["SALES-PHN1"].connections.push_back({"SALES-AP1", "Wireless"});
    
    // ========== FINANCE DEPARTMENT ==========
    
    networkDevices["FIN-SW1"].connections.push_back({"L3-ACTIVE", "Trunk"});
    networkDevices["FIN-SW1"].connections.push_back({"L3-STANDBY", "Trunk"});
    networkDevices["FIN-SW1"].connections.push_back({"FIN-EP1", "Access"});
    networkDevices["FIN-SW1"].connections.push_back({"FIN-LAP1", "Access"});
    networkDevices["FIN-SW1"].connections.push_back({"FIN-AP1", "Access"});
    
    networkDevices["FIN-EP1"].connections.push_back({"FIN-SW1", "Access"});
    networkDevices["FIN-EP1"].connections.push_back({"FIN-PC1", "Passthrough"});
    
    networkDevices["FIN-PC1"].connections.push_back({"FIN-EP1", "Passthrough"});
    
    networkDevices["FIN-LAP1"].connections.push_back({"FIN-SW1", "Access"});
    
    networkDevices["FIN-AP1"].connections.push_back({"FIN-SW1", "Access"});
    networkDevices["FIN-AP1"].connections.push_back({"FIN-TAB1", "Wireless"});
    networkDevices["FIN-AP1"].connections.push_back({"FIN-PHN1", "Wireless"});
    
    networkDevices["FIN-TAB1"].connections.push_back({"FIN-AP1", "Wireless"});
    networkDevices["FIN-PHN1"].connections.push_back({"FIN-AP1", "Wireless"});
    
    // ========== HR DEPARTMENT ==========
    
    networkDevices["HR-SW1"].connections.push_back({"L3-ACTIVE", "Trunk"});
    networkDevices["HR-SW1"].connections.push_back({"L3-STANDBY", "Trunk"});
    networkDevices["HR-SW1"].connections.push_back({"HR-EP1", "Access"});
    networkDevices["HR-SW1"].connections.push_back({"HR-LAP1", "Access"});
    networkDevices["HR-SW1"].connections.push_back({"HR-AP1", "Access"});
    
    networkDevices["HR-EP1"].connections.push_back({"HR-SW1", "Access"});
    networkDevices["HR-EP1"].connections.push_back({"HR-PC1", "Passthrough"});
    
    networkDevices["HR-PC1"].connections.push_back({"HR-EP1", "Passthrough"});
    
    networkDevices["HR-LAP1"].connections.push_back({"HR-SW1", "Access"});
    
    networkDevices["HR-AP1"].connections.push_back({"HR-SW1", "Access"});
    networkDevices["HR-AP1"].connections.push_back({"HR-TAB1", "Wireless"});
    networkDevices["HR-AP1"].connections.push_back({"HR-PHN1", "Wireless"});
    
    networkDevices["HR-TAB1"].connections.push_back({"HR-AP1", "Wireless"});
    networkDevices["HR-PHN1"].connections.push_back({"HR-AP1", "Wireless"});
    
    // ========== INTERNET EDGE ==========
    
    networkDevices["FW-1"].connections.push_back({"CORE-R1", "Routing"});
    networkDevices["FW-1"].connections.push_back({"ISP-R1", "WAN"});
    networkDevices["FW-1"].connections.push_back({"DMZ-L3", "DMZ"});
    
    networkDevices["ISP-R1"].connections.push_back({"FW-1", "WAN"});
    networkDevices["ISP-R1"].connections.push_back({"EXT-R1", "Internet"});
    
    networkDevices["DMZ-L3"].connections.push_back({"FW-1", "DMZ"});
    networkDevices["DMZ-L3"].connections.push_back({"DMZ-SRV", "Access"});
    
    networkDevices["DMZ-SRV"].connections.push_back({"DMZ-L3", "Access"});
    
    networkDevices["EXT-R1"].connections.push_back({"ISP-R1", "Internet"});
    networkDevices["EXT-R1"].connections.push_back({"EXT-L2", "Ethernet"});
    
    networkDevices["EXT-L2"].connections.push_back({"EXT-R1", "Ethernet"});
    networkDevices["EXT-L2"].connections.push_back({"GOOGLE-SRV", "Ethernet"});
    
    networkDevices["GOOGLE-SRV"].connections.push_back({"EXT-L2", "Ethernet"});
    
    logToSyslog(NOTICE, SYSTEM, "CORE-R1", "192.168.1.1",
               "CONNECTIONS_INITIALIZED",
               "All device connections established | Total links: 75", "system");
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS - ADD THIS ENTIRE BLOCK HERE (AFTER LINE 346)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Initialize External Servers
void initializeExternalServers() {
    externalServers["GOOGLE-SRV"] = {
        "GOOGLE-SRV",
        "Google Public DNS Server",
        "8.8.8.8",
        "United States (Cloud)",
        "Google LLC",
        true,
        {},
        0,
        0,
        getCurrentTime()
    };
    
    externalServers["DMZ-SRV"] = {
        "DMZ-SRV",
        "DMZ Public Web Server",
        "172.16.0.10",
        "DMZ Zone (Local)",
        "Cloud TAP Enterprise",
        true,
        {},
        0,
        0,
        getCurrentTime()
    };
    
    externalServers["ISP-R1"] = {
        "ISP-R1",
        "ISP Gateway Router",
        "203.0.113.1",
        "ISP Network Edge",
        "Internet Service Provider",
        true,
        {},
        0,
        0,
        getCurrentTime()
    };
}

// Initialize Firewall ACLs
void initializeFirewallACLs() {
    firewallACLs.push_back({10, "10.10.10.0/24", "ANY", "PERMIT", "ICMP", "Allow Management to all", true});
    firewallACLs.push_back({20, "10.10.20.0/24", "ANY", "PERMIT", "ICMP", "Allow IT to all", true});
    firewallACLs.push_back({30, "10.10.30.0/24", "8.8.8.0/24", "PERMIT", "ICMP", "Allow Sales to Google only", true});
    firewallACLs.push_back({40, "10.10.40.0/24", "172.16.0.0/24", "PERMIT", "ICMP", "Allow Finance to DMZ only", true});
    firewallACLs.push_back({41, "10.10.40.0/24", "ANY", "DENY", "ICMP", "Deny Finance to internet", true});
    firewallACLs.push_back({50, "10.10.50.0/24", "172.16.0.0/24", "PERMIT", "ICMP", "Allow HR to DMZ only", true});
    firewallACLs.push_back({51, "10.10.50.0/24", "ANY", "DENY", "ICMP", "Deny HR to internet", true});
    firewallACLs.push_back({100, "ANY", "ANY", "DENY", "ANY", "Implicit deny all", true});
}

// Check if IP matches network
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIXED ipMatchesNetwork() - SUPPORTS ALL CIDR PREFIXES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool ipMatchesNetwork(const string& ip, const string& network) {
    if (network == "ANY") return true;
    
    size_t slashPos = network.find('/');
    if (slashPos == string::npos) {
        // No CIDR notation, exact match
        return ip == network;
    }
    
    string netAddr = network.substr(0, slashPos);
    int prefix = stoi(network.substr(slashPos + 1));
    
    // âœ… HANDLE DEFAULT ROUTE (0.0.0.0/0) - Matches EVERYTHING
    if (prefix == 0) return true;
    
    // âœ… HANDLE /8 PREFIX (e.g., 8.0.0.0/8)
    if (prefix == 8) {
        string ipFirst = ip.substr(0, ip.find('.'));
        string netFirst = netAddr.substr(0, netAddr.find('.'));
        return ipFirst == netFirst;
    }
    
    // âœ… HANDLE /16 PREFIX (e.g., 10.10.0.0/16)
    if (prefix == 16) {
        size_t ipSecondDot = ip.find('.', ip.find('.') + 1);
        size_t netSecondDot = netAddr.find('.', netAddr.find('.') + 1);
        
        string ipPrefix = ip.substr(0, ipSecondDot);
        string netPrefix = netAddr.substr(0, netSecondDot);
        return ipPrefix == netPrefix;
    }
    
    // âœ… HANDLE /24 PREFIX (e.g., 10.10.10.0/24)
    if (prefix == 24) {
        string ipSubnet = ip.substr(0, ip.rfind('.'));
        string netSubnet = netAddr.substr(0, netAddr.rfind('.'));
        return ipSubnet == netSubnet;
    }
    
    // âœ… HANDLE /30 PREFIX (e.g., 203.0.113.0/30) - Used for point-to-point links
    if (prefix == 30) {
        string ipSubnet = ip.substr(0, ip.rfind('.'));
        string netSubnet = netAddr.substr(0, netAddr.rfind('.'));
        
        int ipLast = stoi(ip.substr(ip.rfind('.') + 1));
        int netLast = stoi(netAddr.substr(netAddr.rfind('.') + 1));
        
        // /30 has 4 IPs: network, host1, host2, broadcast
        // Example: 203.0.113.0/30 â†’ .0 (network), .1 (host), .2 (host), .3 (broadcast)
        return ipSubnet == netSubnet && (ipLast / 4) == (netLast / 4);
    }
    
    // âœ… HANDLE /32 PREFIX (exact host match)
    if (prefix == 32) {
        return ip == netAddr;
    }
    
    // For unsupported prefixes, return false
    return false;
}

// Check Firewall Permission
bool checkFirewallPermission(const string& sourceIP, const string& destIP, const string& protocol = "ICMP") {
    for (const ACLRule& rule : firewallACLs) {
        if (!rule.isActive) continue;
        
        bool sourceMatch = ipMatchesNetwork(sourceIP, rule.sourceNetwork);
        bool destMatch = ipMatchesNetwork(destIP, rule.destinationNetwork);
        bool protocolMatch = (rule.protocol == "ANY" || rule.protocol == protocol);
        
        if (sourceMatch && destMatch && protocolMatch) {
            return (rule.action == "PERMIT");
        }
    }
    return false;
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYSLOG HELPER FUNCTIONS - ADD AFTER checkFirewallPermission()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void logToSyslog(SyslogSeverity severity, SyslogFacility facility,
                 const string& sourceDevice, const string& sourceIP,
                 const string& eventType, const string& message,
                 const string& username = "system")
                  {
    
    SyslogEntry entry = {
        getCurrentTime(),
        severity,
        facility,
        sourceDevice,
        sourceIP,
        eventType,
        message,
        username
    };
    
// âœ… FIXED: Check BEFORE adding (prevents temporary overflow)
    while (syslogDatabase.size() >= MAX_SYSLOG_ENTRIES) {
        syslogDatabase.pop_front();
    }
    
    syslogDatabase.push_back(entry);
    
    syslogStats.totalEvents++;
    switch(severity) {
        case EMERGENCY: syslogStats.emergencyCount++; break;
        case ALERT: syslogStats.alertCount++; break;
        case CRITICAL: syslogStats.criticalCount++; break;
        case ERROR: syslogStats.errorCount++; break;
        case WARNING: syslogStats.warningCount++; break;
        case NOTICE: syslogStats.noticeCount++; break;
        case INFO: syslogStats.infoCount++; break;
        case DEBUG: syslogStats.debugCount++; break;
    }
}
void exportNetworkDataToJSON();
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTING & SWITCHING HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if IP matches network


// Get prefix length from subnet mask
int getPrefixLength(const string& mask) {
    if (mask == "255.255.255.0") return 24;
    if (mask == "255.255.0.0") return 16;
    if (mask == "255.0.0.0") return 8;
    if (mask == "0.0.0.0") return 0;
    return 0;
}

// Find next hop from routing table
string findNextHop(Device& device, const string& targetIP) {
    // L2 devices don't route - use default gateway
    if (device.type == L2_SWITCH || device.type == PC || 
        device.type == LAPTOP || device.type == SERVER) {
        return getDefaultGateway(device);
    }
    
    // L3 devices use routing table
    string bestMatch;
    int longestPrefix = -1;
    
    for (const RouteEntry& route : device.routingTable) {
        if (!route.isActive) continue;
        
        if (ipMatchesNetwork(targetIP, route.destinationNetwork)) {
            int prefixLen = getPrefixLength(route.subnetMask);
            if (prefixLen > longestPrefix) {
                longestPrefix = prefixLen;
                bestMatch = route.nextHop;
                
                // Connected route - target is directly reachable
                if (bestMatch == "0.0.0.0") {
                    bestMatch = targetIP;
                }
            }
        }
    }
    
    return bestMatch;
}

// Calculate realistic latency
int calculateHopLatency(const Device& fromDevice, const string& toIP) {
    // Internet destinations
    if (toIP.substr(0, 4) == "8.8." || toIP.substr(0, 7) == "203.0.1") {
        return 10 + (rand() % 15);  // 10-25ms
    }
    
    // DMZ
    if (toIP.substr(0, 6) == "172.16") {
        return 2 + (rand() % 5);  // 2-7ms
    }
    
    // Same subnet
    if (fromDevice.ipAddress.substr(0, fromDevice.ipAddress.rfind('.')) == 
        toIP.substr(0, toIP.rfind('.'))) {
        return 0;  // <1ms
    }
    
    // Different internal subnet
    return 1 + (rand() % 3);  // 1-4ms
}

// Perform NAT translation
string performNAT(const string& privateIP, const string& firewallId) {
    // Generate public IP from pool
  // âœ… ADD TO CONSTANTS (in NetworkConstants namespace)
const int NAT_POOL_START = 100;
const int NAT_POOL_SIZE = 50;

// Then use:
int lastOctet = NetworkConstants::NAT_POOL_START + (rand() % NetworkConstants::NAT_POOL_SIZE);
    string publicIP = "203.0.113." + to_string(lastOctet);
    
    // Create NAT entry
    NATEntry entry;
    entry.insideLocal = privateIP;
    entry.insideGlobal = publicIP;
    entry.insidePort = 49152 + (rand() % 10000);
    entry.outsidePort = entry.insidePort;
    entry.protocol = "ICMP";
    entry.timestamp = time(0);
    entry.state = "ACTIVE";
    
    natTables[firewallId].push_back(entry);
    
    // Clean old NAT entries (older than 5 minutes)
    time_t now = time(0);
    auto& table = natTables[firewallId];
    table.erase(
        remove_if(table.begin(), table.end(),
            [now](const NATEntry& e) { return (now - e.timestamp) > 300; }),
        table.end()
    );
    
    return publicIP;
}

// Find device by IP address
string findDeviceByIP(const string& ip) {
    for (auto& pair : networkDevices) {
        if (pair.second.ipAddress == ip) {
            return pair.first;
        }
    }
    
    // Check external servers
    if (ip == "8.8.8.8") return "GOOGLE-SRV";
    if (ip == "172.16.0.10") return "DMZ-SRV";
    if (ip == "203.0.113.1") return "ISP-R1";
    
    return "";
}
// Display Beautiful Logo
void displayLogo() {
    cout << CYAN;
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                                                                       â•‘\n";
    cout << "â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                          â•‘\n";
    cout << "â•‘    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—                         â•‘\n";
    cout << "â•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘                         â•‘\n";
    cout << "â•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘                         â•‘\n";
    cout << "â•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•                         â•‘\n";
    cout << "â•‘     â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•                          â•‘\n";
    cout << "â•‘                                                                       â•‘\n";
    cout << "â•‘         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                                      â•‘\n";
    cout << "â•‘         â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    Tier Access Platform             â•‘\n";
    cout << "â•‘            â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    Network Intelligence             â•‘\n";
    cout << "â•‘            â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•     & Topology System                â•‘\n";
    cout << "â•‘            â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘                                          â•‘\n";
    cout << "â•‘            â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•          Version 1.0.0                   â•‘\n";
    cout << "â•‘                                                                       â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << RESET;
}

void displaySystemInfo() {
    cout << CYAN;
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                         DEVELOPMENT TEAM                              â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Project Leader    : Abdul Wahid                                      â•‘\n";
    cout << "â•‘  Core Developer    : Uneeb Ali                                        â•‘\n";
    cout << CYAN;
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Network Status    : " << GREEN << "ONLINE" << WHITE << "                                           â•‘\n";
    cout << "â•‘  System State      : " << GREEN << "READY" << WHITE << "                                            â•‘\n";
    cout << "â•‘  Performance       : " << GREEN << "OPTIMAL" << WHITE << "                                          â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;

    cout << CYAN;
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                      SYSTEM INITIALIZATION                            â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Loading Core Modules........................ " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Initializing Network Graph.................. " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Configuring OSPF Protocol................... " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Establishing HSRP Redundancy................ " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Deploying VLAN Infrastructure............... " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Activating DHCP Server...................... " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Starting Email Service...................... " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << "â•‘  Initializing IP Phone System................ " << GREEN << "DONE" << WHITE << "                    â•‘\n";
    cout << CYAN;
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Devices Loaded    : " << YELLOW << setw(2) << totalDevices << WHITE << "                                               â•‘\n";
    cout << "â•‘  Departments       : " << YELLOW << "5" << WHITE << " (Management, IT, Sales, Finance, HR)           â•‘\n";
    cout << "â•‘  Active Links      : " << YELLOW << totalConnections << WHITE << "                                               â•‘\n";
    cout << "â•‘  Protocols Active  : " << YELLOW << "OSPF | HSRP | LACP | VLANs" << WHITE << "                       â•‘\n";
    cout << "â•‘  DHCP Pools        : " << YELLOW << "7" << WHITE << " (Mgmt, IT, Sales, Finance, HR, Voice, WiFi)    â•‘\n";
    cout << "â•‘  Email Accounts    : " << YELLOW << "5" << WHITE << " (@cloudtap.pk domain)                          â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
}

// Display Network Topology
void displayTopology() {
    system("clear");
    cout << CYAN;
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘               COMPLETE NETWORK TOPOLOGY - 48 DEVICES                  â•‘\n";
    cout << "â•‘                   Enterprise Network Design v1.0                      â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "                    NETWORK SUMMARY                                \n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    cout << CYAN << "  Protocol Stack:  " << WHITE << "OSPF | HSRP+LACP | VLANs | NAT\n";
    cout << CYAN << "  Total Devices:   " << WHITE << totalDevices << " (48 devices)\n";
    cout << CYAN << "  Departments:     " << WHITE << "5 (Management, IT, Sales, Finance, HR)\n";
    cout << CYAN << "  Security Zones:  " << WHITE << "3 (Inside/DMZ/Outside)\n\n" << RESET;
    
    map<string, vector<string>> deptDevices;
    for (auto& pair : networkDevices) {
        deptDevices[pair.second.department].push_back(pair.first);
    }
    
    vector<string> deptOrder = {"Internet", "Security", "DMZ", "Core", "Voice", "Wireless", 
                                "Management", "IT", "Sales", "Finance", "HR"};
    
    for (const string& deptName : deptOrder) {
        if (deptDevices.find(deptName) == deptDevices.end()) continue;
        
        cout << "\n" << YELLOW << "â”â”â”â”â”â”â” " << deptName << " â”â”â”â”â”â”â”\n" << RESET;
        
        for (auto& devId : deptDevices[deptName]) {
            Device& dev = networkDevices[devId];
            cout << CYAN << "  â”œâ”€ " << deviceIcon(dev.type) << " " << dev.name 
                 << RESET << " [" << YELLOW << dev.ipAddress << RESET << "]";
            
            if (dev.vlan != "-" && dev.vlan != "ALL") {
                cout << CYAN << " {" << dev.vlan << "}" << RESET;
            }
            
            if (dev.isDHCP) {
                cout << GREEN << " [DHCP]" << RESET;
            }
            cout << "\n";
        }
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total Network Devices: " << YELLOW << networkDevices.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

// Smart Device Addition - FIXED (Sends notification to BOTH manager AND admin)
void addDeviceSmart() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘           SMART DEVICE ADDITION (AUTO DHCP)                           â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
    cout << CYAN << "STEP 1: Select Department\n" << RESET;
    cout << "  [1] Management  [2] IT  [3] Sales  [4] Finance  [5] HR\n";
   // âœ… REPLACE WITH THIS
cout << WHITE << "Choice: " << RESET;
int deptChoice;
cin >> deptChoice;

// âœ… ADD ERROR HANDLING
if (cin.fail()) {
    cin.clear();
    cin.ignore(10000, '\n');
    cout << RED << "\nâŒ [ERROR] Please enter a number (1-5)!\n" << RESET;
    return;
}

if (deptChoice < 1 || deptChoice > 5) {
    cout << RED << "\n[ERROR] Invalid department!\n" << RESET;
    return;
}
    Department dept = static_cast<Department>(deptChoice - 1);
    
    cout << "\n" << CYAN << "STEP 2: Select Device Type\n" << RESET;
    cout << "  [1] PC  [2] Laptop  [3] IP Phone  [4] Tablet  [5] Mobile Phone\n";
    cout << WHITE << "Choice: " << RESET;
    int typeChoice;
    cin >> typeChoice;
    
    DeviceType type;
    if (typeChoice == 1) type = PC;
    else if (typeChoice == 2) type = LAPTOP;
    else if (typeChoice == 3) type = EPHONE;
    else if (typeChoice == 4) type = TABLET;
    else if (typeChoice == 5) type = PHONE;
    else { 
        cout << RED << "\n[ERROR] Invalid type!\n" << RESET; 
        return; 
    }
    
    cin.ignore();
    cout << "\n" << CYAN << "STEP 3: Device User/Name\n" << RESET;
    cout << WHITE << "Enter name (e.g., John Smith): " << RESET;
    string userName;
    getline(cin, userName);
    
    // Get DHCP IP
    string poolName = getDHCPPoolName(dept, type);
    string ip = getIPFromDHCP(poolName);
    
    if (ip.empty()) {
        cout << RED << "\n[ERROR] DHCP Pool exhausted for " << poolName << "!\n" << RESET;
        cout << YELLOW << "Please contact network administrator to expand the pool.\n" << RESET;
        return;
    }
    
    string vlan = getVLAN(type, dept);
    string subnet = dhcpPools[poolName].subnet;
    string id = deptToString(dept).substr(0,3);
    transform(id.begin(), id.end(), id.begin(), ::toupper);
    id += "-DEV" + to_string(deviceCounter++);
    
    string deviceName = deviceTypeToString(type) + " " + userName;
    
Device newDev = {id, deviceName, ip, subnet, vlan, deptToString(dept), type, {}, true, true, ONLINE, "", "", false};
    networkDevices[id] = newDev;
    totalDevices++;
      // â¬…ï¸ ADD THIS LINE HERE
    logToSyslog(INFO, NETWORK_MANAGEMENT, id, ip, "DEVICE_ADDED",
               "New device: " + deviceName + " | Dept: " + deptToString(dept), "admin");
    // Auto-connect to switch or AP
    string switchId = getDeptSwitch(dept);
    if (!switchId.empty()) {
        if (type == PHONE || type == TABLET) {
            string apId = getDeptAP(dept);
            networkDevices[apId].connections.push_back({id, "WiFi"});
            networkDevices[id].connections.push_back({apId, "WiFi"});
        } else {
            networkDevices[switchId].connections.push_back({id, "Access"});
            networkDevices[id].connections.push_back({switchId, "Access"});
        }
    }
    
    // FIXED: Send notifications to BOTH manager AND department admin
    string managerEmail = "ceo@cloudtap.pk";
    string adminEmail;
    if (dept == MANAGEMENT) adminEmail = "ceo@cloudtap.pk";
    else if (dept == IT) adminEmail = "it.admin@cloudtap.pk";
    else if (dept == SALES) adminEmail = "sales.manager@cloudtap.pk";
    else if (dept == FINANCE) adminEmail = "finance.manager@cloudtap.pk";
    else if (dept == HR) adminEmail = "hr.manager@cloudtap.pk";
    
    // Notification to department admin
    Email notif1 = {
        "system@cloudtap.pk",
        adminEmail,
        "New Device Added to Your Department",
        "Device: " + deviceName + " | IP: " + ip + " | VLAN: " + vlan + " | User: " + userName,
        getCurrentTime(),
        false
    };
    emailInbox.push_back(notif1);
    
    // Notification to manager (if different from admin)
    if (managerEmail != adminEmail) {
        Email notif2 = {
            "system@cloudtap.pk",
            managerEmail,
            "New Device Added - " + deptToString(dept) + " Department",
            "Device: " + deviceName + " | IP: " + ip + " | Department: " + deptToString(dept),
            getCurrentTime(),
            false
        };
        emailInbox.push_back(notif2);
    }
    
    cout << "\n" << GREEN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "       âœ“ DEVICE ADDED SUCCESSFULLY!\n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    cout << CYAN << "Device ID:      " << WHITE << id << "\n";
    cout << CYAN << "Name:           " << WHITE << deviceName << "\n";
    cout << CYAN << "Type:           " << WHITE << deviceTypeToString(type) << "\n";
    cout << CYAN << "Department:     " << WHITE << deptToString(dept) << "\n";
    cout << CYAN << "IP (DHCP):      " << WHITE << ip << "\n";
    cout << CYAN << "VLAN:           " << WHITE << vlan << "\n";
    cout << CYAN << "Subnet:         " << WHITE << subnet << "\n";
    cout << CYAN << "Connected to:   " << WHITE << (type == PHONE || type == TABLET ? getDeptAP(dept) : switchId) << "\n";
    cout << CYAN << "Pool:           " << WHITE << dhcpPools[poolName].poolName << "\n";
    cout << GREEN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    cout << YELLOW << "\nğŸ“§ Notifications sent to:\n";
    cout << "   - Department Admin: " << adminEmail << "\n";
    if (managerEmail != adminEmail) {
        cout << "   - Manager: " << managerEmail << "\n";
    }
    cout << RESET;
    exportNetworkDataToJSON(); 
}

// Remove Device
void removeDevice() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘           DEVICE REMOVAL - IMPACT ANALYSIS                            â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    string id;
    cout << WHITE << "Enter Device ID to remove: " << RESET;
    cin >> id;
    
    if (networkDevices.find(id) == networkDevices.end()) {
        cout << RED << "\n[ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[id];
    
    cout << "\n" << YELLOW << "Target Device: " << WHITE << dev.name << " (" << id << ")\n";
    cout << YELLOW << "IP Address: " << WHITE << dev.ipAddress << "\n";
    cout << YELLOW << "Department: " << WHITE << dev.department << "\n";
    cout << YELLOW << "Device Type: " << WHITE << deviceTypeToString(dev.type) << "\n\n";
    
    set<string> allDependents;
    findAllDependents(id, allDependents);
    
    bool isCriticalInfra = (id == "MGMT-SW1");
    bool hostsCriticalServices = false;
    
    for (const string& depId : allDependents) {
        if (isCriticalServiceHost(depId)) {
            hostsCriticalServices = true;
            break;
        }
    }
    
    if (isCriticalInfra || hostsCriticalServices) {
        cout << RED << "â›” CRITICAL WARNING: " << RESET;
        cout << YELLOW << "This device hosts or connects to ENTERPRISE SERVICES!\n\n" << RESET;
    } else {
        cout << YELLOW << "âš ï¸  WARNING: " << RESET;
        cout << WHITE << "This will affect " << dev.department << " department connectivity\n\n" << RESET;
    }
    
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                     IMPACT ASSESSMENT                                 â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    vector<string> directConnections = getConnectedDevices(id);
    
    if (!directConnections.empty()) {
        cout << YELLOW << "[DIRECTLY CONNECTED] " << WHITE << "(" << directConnections.size() << " devices)\n" << RESET;
        for (const string& connId : directConnections) {
            if (networkDevices.find(connId) != networkDevices.end()) {
                Device& connDev = networkDevices[connId];
                cout << "  ğŸ”´ " << connDev.id << " (" << deviceTypeToString(connDev.type) << ")";
                if (isCriticalServiceHost(connId)) {
                    cout << RED << " âš ï¸  CRITICAL SERVICES HOST" << RESET;
                }
                cout << " â†’ Will become OFFLINE\n";
            }
        }
        cout << "\n";
    }
    
    set<string> indirectDeps = allDependents;
    for (const string& dir : directConnections) {
        indirectDeps.erase(dir);
    }
    
    if (!indirectDeps.empty()) {
        cout << YELLOW << "[INDIRECTLY AFFECTED] " << WHITE << "(" << indirectDeps.size() << " devices)\n" << RESET;
        for (const string& depId : indirectDeps) {
            if (networkDevices.find(depId) != networkDevices.end()) {
                Device& depDev = networkDevices[depId];
                cout << "  ğŸ”´ " << depDev.id << " (" << deviceTypeToString(depDev.type) << ")\n";
            }
        }
        cout << "\n";
    }
    
    if (isCriticalInfra || hostsCriticalServices) {
        cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RED << "[CRITICAL SERVICE IMPACT] - ALL DEPARTMENTS AFFECTED âš ï¸\n\n" << RESET;
        
        cout << RED << "  â›” DHCP SERVICE: UNAVAILABLE\n" << RESET;
        cout << WHITE << "     Impact: Network-wide\n";
        cout << "     â€¢ Existing devices: Will RETAIN IPs (until lease expires)\n";
        cout << "     â€¢ New devices: " << RED << "CANNOT obtain IPs âŒ\n" << RESET;
        cout << "     â€¢ All 7 DHCP pools affected\n\n";
        
        cout << RED << "  â›” EMAIL SERVICE: UNAVAILABLE\n" << RESET;
        cout << WHITE << "     Impact: All departments\n";
        cout << "     â€¢ Cannot send/receive emails\n";
        cout << "     â€¢ Email accounts affected: 5 (@cloudtap.pk)\n\n";
        
        cout << RED << "  â›” WEB DATABASE: UNAVAILABLE\n" << RESET;
        cout << WHITE << "     Impact: All departments\n";
        cout << "     â€¢ http://10.10.10.10 â†’ CONNECTION REFUSED\n";
        cout << "     â€¢ Network monitoring: UNAVAILABLE\n\n";
        
    } else {
        cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << GREEN << "[NETWORK SERVICES STATUS]\n\n" << RESET;
        
        cout << GREEN << "  âœ… DHCP SERVICE: OPERATIONAL\n" << RESET;
        cout << WHITE << "     MGMT-SRV1 (10.10.10.10) is ONLINE\n";
        cout << "     â€¢ Other departments can still add devices\n\n";
        
        cout << GREEN << "  âœ… EMAIL SERVICE: OPERATIONAL\n" << RESET;
        cout << WHITE << "     MGMT-SRV1 (10.10.10.10) is ONLINE\n";
        cout << "     â€¢ Other departments unaffected\n\n";
        
        cout << GREEN << "  âœ… WEB SERVICE: OPERATIONAL\n" << RESET;
        cout << WHITE << "     MGMT-SRV1 (10.10.10.10) is ONLINE\n";
        cout << "     â€¢ Other departments can access web interface\n\n";
    }
    
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << YELLOW << "ğŸ“Š SUMMARY:\n" << RESET;
    cout << "   Directly Offline: " << directConnections.size() << " devices\n";
    cout << "   Indirectly Affected: " << indirectDeps.size() << " devices\n";
    cout << "   Total Impact: " << allDependents.size() << " devices\n";
    
    if (isCriticalInfra || hostsCriticalServices) {
        cout << RED << "   Critical Services: âŒ WILL GO OFFLINE\n";
        cout << "   Global Impact: ALL 5 DEPARTMENTS\n" << RESET;
    } else {
        cout << GREEN << "   Critical Services: âœ… REMAIN OPERATIONAL\n";
        cout << "   Impact Scope: LOCAL (" << dev.department << " only)\n" << RESET;
    }
    
    cout << CYAN << "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << YELLOW << "Type 'yes' to confirm removal, 'no' to cancel: " << RESET;
    string confirm;
    cin >> confirm;
    
    if (confirm != "yes" && confirm != "YES") {
        cout << GREEN << "\nâœ“ Removal cancelled.\n" << RESET;
        return;
    }
    
    cout << "\n" << YELLOW << "â³ Processing removal...\n\n" << RESET;
    
    string timestamp = getCurrentTime();
    
    logToSyslog(CRITICAL, NETWORK_MANAGEMENT, dev.id, dev.ipAddress, 
               "DEVICE_REMOVED",
               "Device removed: " + dev.name + " | Dependents: " + to_string(allDependents.size()), "admin");
    
    if (isCriticalInfra || hostsCriticalServices) {
        globalServices.dhcpOnline = false;
        globalServices.emailOnline = false;
        globalServices.webOnline = false;
        
        logToSyslog(ERROR, DHCP_SERVER, "MGMT-SRV1", "10.10.10.10",
                   "SERVICE_OFFLINE",
                   "DHCP Server offline | All pools unavailable", "system");
        
        logToSyslog(ERROR, EMAIL_SERVER, "MGMT-SRV1", "10.10.10.10",
                   "SERVICE_OFFLINE",
                   "Email Server offline | 5 accounts unreachable", "system");
        
        logToSyslog(ERROR, WEB_SERVER, "MGMT-SRV1", "10.10.10.10",
                   "SERVICE_OFFLINE",
                   "Web Server offline | http://10.10.10.10 unavailable", "system");
    }
    
    dev.status = REMOVED;
    dev.isActive = false;
    dev.offlineReason = "Device removed from network";
    dev.removedTimestamp = timestamp;
    
    for (const string& connId : directConnections) {
        if (networkDevices.find(connId) != networkDevices.end()) {
            Device& connDev = networkDevices[connId];
            connDev.status = OFFLINE;
            connDev.isActive = false;
            connDev.offlineReason = "Parent device " + id + " removed";
            
            logToSyslog(WARNING, NETWORK_MANAGEMENT, connDev.id, connDev.ipAddress,
                       "CONNECTION_LOST",
                       "Lost uplink to " + id + " | Status: OFFLINE", "system");
        }
    }
    
    for (const string& depId : indirectDeps) {
        if (networkDevices.find(depId) != networkDevices.end()) {
            Device& depDev = networkDevices[depId];
            
            if (depDev.type == TABLET || depDev.type == PHONE) {
                depDev.status = WIRELESS_DOWN;
                depDev.offlineReason = "Access Point lost uplink";
            } else if (depDev.type == PC) {
                depDev.status = UNREACHABLE;
                depDev.offlineReason = "Lost connection via passthrough";
            } else {
                depDev.status = UNREACHABLE;
                depDev.offlineReason = "Network path unavailable";
            }
            
            depDev.isActive = false;
            
            logToSyslog(WARNING, NETWORK_MANAGEMENT, depDev.id, depDev.ipAddress,
                       "NETWORK_UNREACHABLE",
                       "Lost network path | Status: " + deviceStatusToString(depDev.status), "system");
        }
    }
    
   // âœ… FIXED: Remove ALL connections (including zombie connections)
    set<string> devicesToClean = allDependents;
    devicesToClean.insert(id);
    
    for (auto& pair : networkDevices) {
        auto& conns = pair.second.connections;
        
        // Remove connections to the removed device
        conns.erase(remove_if(conns.begin(), conns.end(),
            [&id](const Connection& c) { return c.targetDevice == id; }), conns.end());
        
        // If this is an offline device, also clean its connections
        if (devicesToClean.count(pair.first)) {
            conns.erase(remove_if(conns.begin(), conns.end(),
                [&devicesToClean](const Connection& c) { 
                    return devicesToClean.count(c.targetDevice) > 0; 
                }), conns.end());
        }
    }
    if (dev.isDHCP) {
        string poolName = getDHCPPoolName(static_cast<Department>(0), dev.type);
        if (dev.vlan == "VLAN60") poolName = "VOICE-POOL";
        else if (dev.vlan == "VLAN70") poolName = "WIRELESS-POOL";
        else if (dev.vlan == "VLAN10") poolName = "MGMT-POOL";
        else if (dev.vlan == "VLAN20") poolName = "IT-POOL";
        else if (dev.vlan == "VLAN30") poolName = "SALES-POOL";
        else if (dev.vlan == "VLAN40") poolName = "FIN-POOL";
        else if (dev.vlan == "VLAN50") poolName = "HR-POOL";
        
        if (!poolName.empty() && dhcpPools.find(poolName) != dhcpPools.end()) {
            int lastOctet = stoi(dev.ipAddress.substr(dev.ipAddress.rfind('.') + 1));
            dhcpPools[poolName].usedIPs.erase(lastOctet);
        }
    }
    
    totalDevices--;
    
    vector<string> recipients;
    
    if (isCriticalInfra || hostsCriticalServices) {
        recipients = {"ceo@cloudtap.pk", "it.admin@cloudtap.pk", 
                     "sales.manager@cloudtap.pk", "finance.manager@cloudtap.pk", 
                     "hr.manager@cloudtap.pk"};
        
        for (const string& email : recipients) {
            Email alert = {
                "system@cloudtap.pk", email,
                "CRITICAL: Enterprise Services Offline",
                "Device " + id + " removed. DHCP, Email, Web services UNAVAILABLE.",
                timestamp, false
            };
            emailInbox.push_back(alert);
        }
    } else {
        string deptEmail = "ceo@cloudtap.pk";
        if (dev.department == "IT") deptEmail = "it.admin@cloudtap.pk";
        else if (dev.department == "Sales") deptEmail = "sales.manager@cloudtap.pk";
        else if (dev.department == "Finance") deptEmail = "finance.manager@cloudtap.pk";
        else if (dev.department == "HR") deptEmail = "hr.manager@cloudtap.pk";
        
        Email alert = {
            "system@cloudtap.pk", deptEmail,
            "Device Removed - " + dev.department,
            "Device " + id + " removed. " + to_string(allDependents.size()) + " devices affected.",
            timestamp, false
        };
        emailInbox.push_back(alert);
    }
    
    cout << GREEN << "âœ“ Removal completed successfully\n";
    cout << "âœ“ Notifications sent\n" << RESET;
    exportNetworkDataToJSON(); 
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART 3: ADVANCED SEARCH SYSTEM - ADD AFTER removeDevice()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Search Device by ID
vector<string> searchByID(const string& query) {
    vector<string> results;
    string lowerQuery = query;
    transform(lowerQuery.begin(), lowerQuery.end(), lowerQuery.begin(), ::tolower);
    
    for (auto& pair : networkDevices) {
        string lowerID = pair.first;
        transform(lowerID.begin(), lowerID.end(), lowerID.begin(), ::tolower);
        
        if (lowerID.find(lowerQuery) != string::npos) {
            results.push_back(pair.first);
        }
    }
    return results;
}

// Search Device by IP Address
vector<string> searchByIP(const string& query) {
    vector<string> results;
    
    for (auto& pair : networkDevices) {
        if (pair.second.ipAddress.find(query) != string::npos) {
            results.push_back(pair.first);
        }
    }
    return results;
}

// Search Device by Name
vector<string> searchByName(const string& query) {
    vector<string> results;
    string lowerQuery = query;
    transform(lowerQuery.begin(), lowerQuery.end(), lowerQuery.begin(), ::tolower);
    
    for (auto& pair : networkDevices) {
        string lowerName = pair.second.name;
        transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
        
        if (lowerName.find(lowerQuery) != string::npos) {
            results.push_back(pair.first);
        }
    }
    return results;
}

// Search Device by Department
vector<string> searchByDepartment(const string& dept) {
    vector<string> results;
    string lowerDept = dept;
    transform(lowerDept.begin(), lowerDept.end(), lowerDept.begin(), ::tolower);
    
    for (auto& pair : networkDevices) {
        string lowerDevDept = pair.second.department;
        transform(lowerDevDept.begin(), lowerDevDept.end(), lowerDevDept.begin(), ::tolower);
        
        if (lowerDevDept.find(lowerDept) != string::npos) {
            results.push_back(pair.first);
        }
    }
    return results;
}

// Search Device by Type
vector<string> searchByType(DeviceType type) {
    vector<string> results;
    
    for (auto& pair : networkDevices) {
        if (pair.second.type == type) {
            results.push_back(pair.first);
        }
    }
    return results;
}

// Display Search Results
void displaySearchResults(const vector<string>& results, const string& searchType) {
    if (results.empty()) {
        cout << RED << "\nâŒ No devices found matching your search.\n" << RESET;
        return;
    }
    
    cout << "\n" << GREEN << "âœ“ Found " << results.size() << " device(s):\n" << RESET;
    cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
    
    // âœ… ADD BOUNDS CHECK
for (size_t i = 0; i < results.size(); i++) {
    // âœ… CHECK IF DEVICE EXISTS
    if (networkDevices.find(results[i]) == networkDevices.end()) {
        cout << RED << "âš ï¸ Device " << results[i] << " no longer exists\n" << RESET;
        continue;
    }
    Device& dev = networkDevices[results[i]];
        
        cout << YELLOW << "\n[" << (i+1) << "] " << WHITE << dev.name << " (" << dev.id << ")\n" << RESET;
        cout << CYAN << "    â”œâ”€ Type:       " << WHITE << deviceTypeToString(dev.type) << "\n";
        cout << CYAN << "    â”œâ”€ IP:         " << WHITE << dev.ipAddress << "\n";
        cout << CYAN << "    â”œâ”€ VLAN:       " << WHITE << dev.vlan << "\n";
        cout << CYAN << "    â”œâ”€ Department: " << WHITE << dev.department << "\n";
        cout << CYAN << "    â”œâ”€ Status:     ";
        
        if (dev.isActive) {
            cout << GREEN << "ğŸŸ¢ ONLINE\n" << RESET;
        } else {
            cout << RED << "ğŸ”´ OFFLINE\n" << RESET;
        }
        
        cout << CYAN << "    â””â”€ Connections: " << WHITE << dev.connections.size() << " links\n" << RESET;
    }
    
    cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
}

// Main Search Interface
void searchDeviceMenu() {
    while(true) {
        system("clear");
cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                    ğŸ” DEVICE SEARCH SYSTEM                            â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  [1] Search by Device ID                                              â•‘\n";
        cout << "â•‘  [2] Search by IP Address                                             â•‘\n";
        cout << "â•‘  [3] Search by Device Name                                            â•‘\n";
        cout << "â•‘  [4] Search by Department                                             â•‘\n";
        cout << "â•‘  [5] Search by Device Type                                            â•‘\n";
        cout << "â•‘  [6] Advanced Search (Multiple Filters)                               â•‘\n";
        cout << "â•‘  [0] Back to Network Management                                       â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
       // âœ… REPLACE WITH THIS
cout << CYAN << "Search >> " << RESET;
int choice;
cin >> choice;

// âœ… ADD ERROR HANDLING
if (cin.fail()) {
    cin.clear();
    cin.ignore(10000, '\n');
    cout << RED << "\nâŒ Invalid input! Enter a number.\n" << RESET;
    this_thread::sleep_for(chrono::seconds(1));
    continue;
}

cin.ignore();
        
        if (choice == 0) return;
        
        vector<string> results;
        string query;
        
        switch(choice) {
            case 1:
                cout << WHITE << "\nEnter Device ID (or part of it): " << RESET;
                getline(cin, query);
                results = searchByID(query);
                displaySearchResults(results, "ID");
                break;
                
            case 2:
                cout << WHITE << "\nEnter IP Address (or part of it): " << RESET;
                getline(cin, query);
                results = searchByIP(query);
                displaySearchResults(results, "IP");
                break;
                
            case 3:
                cout << WHITE << "\nEnter Device Name (or part of it): " << RESET;
                getline(cin, query);
                results = searchByName(query);
                displaySearchResults(results, "Name");
                break;
                
            case 4:
                cout << WHITE << "\nEnter Department (Management/IT/Sales/Finance/HR): " << RESET;
                getline(cin, query);
                results = searchByDepartment(query);
                displaySearchResults(results, "Department");
                break;
                
            case 5: {
                cout << "\n" << CYAN << "Select Device Type:\n" << RESET;
                cout << "  [1] Router  [2] L3 Switch  [3] L2 Switch  [4] Firewall\n";
                cout << "  [5] Server  [6] PC  [7] Laptop  [8] IP Phone  [9] Tablet\n";
                cout << WHITE << "Choice: " << RESET;
                int typeChoice;
                cin >> typeChoice;
                cin.ignore();
                
                DeviceType type;
                switch(typeChoice) {
                    case 1: type = ROUTER; break;
                    case 2: type = L3_SWITCH; break;
                    case 3: type = L2_SWITCH; break;
                    case 4: type = FIREWALL; break;
                    case 5: type = SERVER; break;
                    case 6: type = PC; break;
                    case 7: type = LAPTOP; break;
                    case 8: type = EPHONE; break;
                    case 9: type = TABLET; break;
                    default: 
                        cout << RED << "\n[ERROR] Invalid type!\n" << RESET;
                        continue;
                }
                
                results = searchByType(type);
                displaySearchResults(results, "Type");
                break;
            }
                
            case 6: {
                // Advanced Search with multiple filters
                cout << "\n" << YELLOW << "ğŸ” ADVANCED SEARCH MODE\n" << RESET;
                cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
                
                cout << WHITE << "\nEnter Department (or press Enter to skip): " << RESET;
                string dept;
                getline(cin, dept);
                
                cout << WHITE << "Enter IP pattern (or press Enter to skip): " << RESET;
                string ip;
                getline(cin, ip);
                
                cout << WHITE << "Show only ONLINE devices? (y/n): " << RESET;
                char onlineOnly;
                cin >> onlineOnly;
                
                // Combine filters
                set<string> filteredResults;
                
                // Start with all devices
                for (auto& pair : networkDevices) {
                    filteredResults.insert(pair.first);
                }
                
                // Apply department filter
                if (!dept.empty()) {
                    vector<string> deptResults = searchByDepartment(dept);
                    set<string> deptSet(deptResults.begin(), deptResults.end());
                    set<string> intersection;
                    set_intersection(filteredResults.begin(), filteredResults.end(),
                                   deptSet.begin(), deptSet.end(),
                                   inserter(intersection, intersection.begin()));
                    filteredResults = intersection;
                }
                
                // Apply IP filter
                if (!ip.empty()) {
                    vector<string> ipResults = searchByIP(ip);
                    set<string> ipSet(ipResults.begin(), ipResults.end());
                    set<string> intersection;
                    set_intersection(filteredResults.begin(), filteredResults.end(),
                                   ipSet.begin(), ipSet.end(),
                                   inserter(intersection, intersection.begin()));
                    filteredResults = intersection;
                }
                
                // Apply online filter
                if (onlineOnly == 'y' || onlineOnly == 'Y') {
                    set<string> onlineSet;
                    for (const string& devId : filteredResults) {
                        if (networkDevices[devId].isActive) {
                            onlineSet.insert(devId);
                        }
                    }
                    filteredResults = onlineSet;
                }
                
                vector<string> finalResults(filteredResults.begin(), filteredResults.end());
                displaySearchResults(finalResults, "Advanced");
                break;
            }
                
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
        }
        
        cout << "\nPress Enter to continue...";
        cin.get();
    }
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART 4: PING SYSTEM - PASTE THIS COMPLETE BLOCK HERE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Simulate Ping with Firewall ACL Check
PingRecord simulatePing(const string& sourceDeviceId, const string& targetIP) {
    PingRecord record;
    record.timestamp = getCurrentTime();
    record.targetIP = targetIP;
    
    if (networkDevices.find(sourceDeviceId) == networkDevices.end()) {
        record.success = false;
        record.latency = 0;
        return record;
    }
    
    Device& sourceDev = networkDevices[sourceDeviceId];
    record.sourceDevice = sourceDev.name;
    record.sourceIP = sourceDev.ipAddress;
    record.targetDevice = "Unknown";
    
    for (auto& pair : networkDevices) {
        if (pair.second.ipAddress == targetIP) {
            record.targetDevice = pair.second.name;
            break;
        }
    }
    
    if (externalServers.find("GOOGLE-SRV") != externalServers.end() && 
        externalServers["GOOGLE-SRV"].ipAddress == targetIP) {
        record.targetDevice = "Google DNS Server";
    } else if (externalServers.find("DMZ-SRV") != externalServers.end() && 
               externalServers["DMZ-SRV"].ipAddress == targetIP) {
        record.targetDevice = "DMZ Web Server";
    } else if (externalServers.find("ISP-R1") != externalServers.end() && 
               externalServers["ISP-R1"].ipAddress == targetIP) {
        record.targetDevice = "ISP Gateway";
    }
    
    bool permitted = checkFirewallPermission(record.sourceIP, targetIP, "ICMP");
    
    if (!permitted) {
        record.success = false;
        record.latency = 0;
        record.ttl = 0;
        record.packetsSent = 4;
        record.packetsReceived = 0;
        record.packetLoss = 100.0;
        return record;
    }
    
    record.success = true;
    record.packetsSent = 4;
    record.packetsReceived = 4;
    record.packetLoss = 0.0;
    record.ttl = 64;
    
  // âœ… REPLACE WITH CONSTANTS
// âœ… CORRECT CODE - USE THIS
    if (targetIP.substr(0, 4) == "8.8.") {
        record.latency = NetworkConstants::LATENCY_INTERNET_MIN + 
                        (rand() % (NetworkConstants::LATENCY_INTERNET_MAX - 
                                  NetworkConstants::LATENCY_INTERNET_MIN));
    } else if (targetIP.substr(0, 6) == "172.16") {
        record.latency = NetworkConstants::LATENCY_DMZ_MIN + 
                        (rand() % (NetworkConstants::LATENCY_DMZ_MAX - 
                                  NetworkConstants::LATENCY_DMZ_MIN));
    } else if (targetIP.substr(0, 7) == "203.0.1") {
        record.latency = NetworkConstants::LATENCY_WAN_MIN + 
                        (rand() % (NetworkConstants::LATENCY_WAN_MAX - 
                                  NetworkConstants::LATENCY_WAN_MIN));
    } else {
        record.latency = NetworkConstants::LATENCY_LOCAL_MIN + 
                        (rand() % (NetworkConstants::LATENCY_LOCAL_MAX - 
                                  NetworkConstants::LATENCY_LOCAL_MIN));
    }
    
    return record;
}

// Perform Ping Operation
void performPing() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                    ğŸŒ PING UTILITY (ICMP Echo)                        â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Test network connectivity with firewall ACL validation               â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << YELLOW << "STEP 1: Select Source Device\n" << RESET;
    cout << "Enter device ID (e.g., MGMT-PC1, IT-LAP1): ";
    string sourceId;
    cin >> sourceId;
    
    if (networkDevices.find(sourceId) == networkDevices.end()) {
        cout << RED << "\n[ERROR] Source device not found!\n" << RESET;
        return;
    }
    
    Device& sourceDev = networkDevices[sourceId];
    cout << GREEN << "âœ“ Source: " << WHITE << sourceDev.name << " (" << sourceDev.ipAddress << ")\n\n";
    
    cout << YELLOW << "STEP 2: Select Target\n" << RESET;
    cout << "  [1] Internal Device (by IP)\n";
    cout << "  [2] Google Server (8.8.8.8)\n";
    cout << "  [3] DMZ Server (172.16.0.10)\n";
    cout << "  [4] ISP Gateway (203.0.113.1)\n";
    cout << WHITE << "Choice: " << RESET;
    int targetChoice;
    cin >> targetChoice;
    
    string targetIP;
    
    if (targetChoice == 1) {
        cout << WHITE << "Enter target IP address: " << RESET;
        cin >> targetIP;
    } else if (targetChoice == 2) {
        targetIP = "8.8.8.8";
    } else if (targetChoice == 3) {
        targetIP = "172.16.0.10";
    } else if (targetChoice == 4) {
        targetIP = "203.0.113.1";
    } else {
        cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
        return;
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Pinging " << YELLOW << targetIP << CYAN << " from " << YELLOW << sourceDev.ipAddress << CYAN << "...\n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    this_thread::sleep_for(chrono::milliseconds(500));
    
    PingRecord record = simulatePing(sourceId, targetIP);
    
    cout << "\n";
    if (record.success) {
        cout << GREEN << "âœ“ PING SUCCESSFUL\n" << RESET;
        cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
        
        for (int i = 0; i < 4; i++) {
            cout << "Reply from " << YELLOW << targetIP << RESET 
                 << ": bytes=32 time=" << GREEN << record.latency << "ms" << RESET 
                 << " TTL=" << record.ttl << "\n";
            this_thread::sleep_for(chrono::milliseconds(200));
        }
        
        cout << "\n" << CYAN << "Ping statistics for " << targetIP << ":\n" << RESET;
        cout << "    Packets: Sent = " << record.packetsSent 
             << ", Received = " << GREEN << record.packetsReceived << RESET 
             << ", Lost = 0 (" << record.packetLoss << "% loss)\n";
        cout << "Approximate round trip times:\n";
        cout << "    Minimum = " << record.latency - 1 << "ms, "
             << "Maximum = " << record.latency + 1 << "ms, "
             << "Average = " << record.latency << "ms\n";
           // â¬…ï¸ ADD THIS LINE HERE
        logToSyslog(INFO, PING_SERVICE, record.sourceDevice, record.sourceIP,
                   "PING_SUCCESS", "Ping to " + targetIP + " succeeded | Latency: " + 
                   to_string(record.latency) + "ms", "user");
        
        globalPingHistory.push_back(record);
        
        if (targetIP == "8.8.8.8" && externalServers.find("GOOGLE-SRV") != externalServers.end()) {
            externalServers["GOOGLE-SRV"].pingHistory.push_back(record);
            externalServers["GOOGLE-SRV"].totalRequests++;
            externalServers["GOOGLE-SRV"].successfulRequests++;
            externalServers["GOOGLE-SRV"].lastAccessTime = getCurrentTime();
        } else if (targetIP == "172.16.0.10" && externalServers.find("DMZ-SRV") != externalServers.end()) {
            externalServers["DMZ-SRV"].pingHistory.push_back(record);
            externalServers["DMZ-SRV"].totalRequests++;
            externalServers["DMZ-SRV"].successfulRequests++;
            externalServers["DMZ-SRV"].lastAccessTime = getCurrentTime();
        } else if (targetIP == "203.0.113.1" && externalServers.find("ISP-R1") != externalServers.end()) {
            externalServers["ISP-R1"].pingHistory.push_back(record);
            externalServers["ISP-R1"].totalRequests++;
            externalServers["ISP-R1"].successfulRequests++;
            externalServers["ISP-R1"].lastAccessTime = getCurrentTime();
        }
        
    } else {
        cout << RED << "âœ— PING FAILED - FIREWALL BLOCKED\n" << RESET;
        cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
        cout << RED << "Request timed out (Firewall ACL denied)\n" << RESET;
        cout << "\n" << YELLOW << "âš ï¸  Firewall Rule:\n" << RESET;
        cout << "   Source " << sourceDev.ipAddress << " is NOT PERMITTED to ping " << targetIP << "\n";
        cout << "   Protocol: ICMP | Action: DENY\n";
        // NEW:
        logToSyslog(WARNING, FIREWALL_FACILITY, record.sourceDevice, record.sourceIP,
                   "PING_BLOCKED", "Firewall blocked ping to " + targetIP + " | ACL: DENY", "firewall");  
        globalPingHistory.push_back(record);
        
        if (targetIP == "8.8.8.8" && externalServers.find("GOOGLE-SRV") != externalServers.end()) {
            externalServers["GOOGLE-SRV"].totalRequests++;
        } else if (targetIP == "172.16.0.10" && externalServers.find("DMZ-SRV") != externalServers.end()) {
            externalServers["DMZ-SRV"].totalRequests++;
        } else if (targetIP == "203.0.113.1" && externalServers.find("ISP-R1") != externalServers.end()) {
            externalServers["ISP-R1"].totalRequests++;
        }
    }
    
    cout << CYAN << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" << RESET;
}

// View Ping History
void viewPingHistory() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                      ğŸ“Š PING HISTORY (LOCAL)                          â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    if (globalPingHistory.empty()) {
        cout << YELLOW << "No ping records. Perform some pings first!\n" << RESET;
        return;
    }
    
    cout << GREEN << "Total Records: " << WHITE << globalPingHistory.size() << "\n\n" << RESET;
    
    for (size_t i = 0; i < globalPingHistory.size(); i++) {
        const PingRecord& r = globalPingHistory[i];
        cout << CYAN << "[" << (i + 1) << "] " << r.timestamp << "\n" << RESET;
        cout << "    Source: " << YELLOW << r.sourceDevice << RESET << " (" << r.sourceIP << ")\n";
        cout << "    Target: " << YELLOW << r.targetDevice << RESET << " (" << r.targetIP << ")\n";
        
        if (r.success) {
            cout << "    Result: " << GREEN << "âœ“ SUCCESS" << RESET 
                 << " | Latency: " << r.latency << "ms\n";
        } else {
            cout << "    Result: " << RED << "âœ— FAILED (Firewall Blocked)" << RESET << "\n";
        }
        cout << "\n";
    }
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IPCONFIG - NETWORK INTERFACE CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void displayIPConfig() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ’» IPCONFIG - Network Configuration                 â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  View detailed network interface configuration                        â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., MGMT-PC1): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Windows IP Configuration - " << dev.name << string(48 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << "\n" << CYAN << "Host Name . . . . . . . . . . . . : " << WHITE << dev.name << RESET << "\n";
    cout << CYAN << "Primary DNS Suffix  . . . . . . . : " << WHITE << "cloudtap.pk" << RESET << "\n";
    cout << CYAN << "Node Type . . . . . . . . . . . . : " << WHITE << "Hybrid" << RESET << "\n";
    cout << CYAN << "IP Routing Enabled. . . . . . . . : " << WHITE << (dev.type == ROUTER || dev.type == L3_SWITCH ? "Yes" : "No") << RESET << "\n";
    cout << CYAN << "WINS Proxy Enabled. . . . . . . . : " << WHITE << "No" << RESET << "\n\n";
    
    for (size_t i = 0; i < dev.interfaces.size(); i++) {
        const NetworkInterface& iface = dev.interfaces[i];
        
        cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        cout << "Interface: " << iface.interfaceName << "\n";
        cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
        
        cout << "\n";
        cout << CYAN << "   Connection-specific DNS Suffix  . : " << WHITE << "cloudtap.pk\n" << RESET;
        cout << CYAN << "   Description . . . . . . . . . . . : " << WHITE << deviceTypeToString(dev.type) << " Adapter\n" << RESET;
        cout << CYAN << "   Physical Address (MAC). . . . . . : " << GREEN << iface.macAddress << RESET << "\n";
        cout << CYAN << "   DHCP Enabled. . . . . . . . . . . : " << (iface.dhcpEnabled ? GREEN "Yes" : YELLOW "No") << RESET << "\n";
        
        if (iface.dhcpEnabled) {
            cout << CYAN << "   DHCP Server . . . . . . . . . . . : " << YELLOW << iface.dhcpServer << RESET << "\n";
        }
        
        cout << CYAN << "   Autoconfiguration Enabled . . . . : " << WHITE << "Yes\n" << RESET;
        cout << CYAN << "   IPv4 Address. . . . . . . . . . . : " << GREEN << iface.ipAddress << RESET;
        
        if (iface.dhcpEnabled) {
            cout << YELLOW << " (DHCP)" << RESET;
        } else {
            cout << CYAN << " (Static)" << RESET;
        }
        cout << "\n";
        
        cout << CYAN << "   Subnet Mask . . . . . . . . . . . : " << WHITE << iface.subnetMask << RESET << "\n";
        cout << CYAN << "   Default Gateway . . . . . . . . . : " << YELLOW << iface.defaultGateway << RESET << "\n";
        cout << CYAN << "   DNS Servers . . . . . . . . . . . : " << YELLOW << iface.dnsServer << RESET << "\n";
        cout << CYAN << "   NetBIOS over Tcpip. . . . . . . . : " << WHITE << "Enabled\n" << RESET;
        cout << CYAN << "   MTU . . . . . . . . . . . . . . . : " << WHITE << iface.mtu << " bytes\n" << RESET;
        
        cout << "\n" << MAGENTA << "   Interface Statistics:\n" << RESET;
        cout << CYAN << "   â”œâ”€ Status . . . . . . . . . . . . : " << (iface.interfaceStatus == "UP" ? GREEN "UP âœ“" : RED "DOWN âœ—") << RESET << "\n";
        cout << CYAN << "   â”œâ”€ Bytes Received . . . . . . . . : " << WHITE << iface.bytesReceived << RESET << "\n";
        cout << CYAN << "   â”œâ”€ Bytes Sent . . . . . . . . . . : " << WHITE << iface.bytesSent << RESET << "\n";
        cout << CYAN << "   â”œâ”€ Packets Received . . . . . . . : " << WHITE << iface.packetsReceived << RESET << "\n";
        cout << CYAN << "   â””â”€ Packets Sent . . . . . . . . . : " << WHITE << iface.packetsSent << RESET << "\n";
        
        cout << "\n";
    }
    
    logToSyslog(INFO, NETWORK_MANAGEMENT, dev.id, dev.ipAddress,
               "IPCONFIG_QUERY", "Network configuration queried by user", "user");
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETSTAT - NETWORK STATISTICS & ACTIVE CONNECTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void displayNetstat() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ“Š NETSTAT - Network Statistics                     â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Display active TCP connections and listening ports                  â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., MGMT-PC1): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    // Simulate active connections
    simulateActiveConnections(dev);
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Active Connections for " << dev.name << string(47 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    if (dev.activeConnections.empty()) {
        cout << "\n" << YELLOW << "â„¹ï¸  No active connections found.\n" << RESET;
    } else {
        cout << "\n";
        cout << left << CYAN
             << setw(8) << "Proto"
             << setw(26) << "Local Address"
             << setw(26) << "Foreign Address"
             << setw(18) << "State"
             << setw(8) << "PID"
             << RESET << "\n";
        cout << string(86, '-') << "\n";
        
        for (const ConnectionState& conn : dev.activeConnections) {
            cout << left << WHITE
                 << setw(8) << conn.protocol
                 << setw(26) << (conn.localAddress + ":" + to_string(conn.localPort))
                 << setw(26) << (conn.remoteAddress + ":" + to_string(conn.remotePort));
            
            if (conn.state == "ESTABLISHED") cout << GREEN;
            else if (conn.state == "LISTENING") cout << YELLOW;
            else if (conn.state == "TIME_WAIT") cout << MAGENTA;
            else cout << WHITE;
            
            cout << setw(18) << conn.state << RESET
                 << setw(8) << conn.pid
                 << "\n";
        }
    }
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Listening Ports                                                      â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    if (dev.listeningPorts.empty()) {
        cout << "\n" << YELLOW << "â„¹ï¸  No listening ports configured.\n" << RESET;
    } else {
        cout << "\n";
        cout << left << CYAN
             << setw(8) << "Proto"
             << setw(24) << "Local Address"
             << setw(18) << "State"
             << setw(20) << "Service"
             << RESET << "\n";
        cout << string(70, '-') << "\n";
        
        for (const ListeningPort& port : dev.listeningPorts) {
            if (port.isActive) {
                cout << left << WHITE
                     << setw(8) << port.protocol
                     << setw(24) << (port.bindAddress + ":" + to_string(port.port))
                     << GREEN << setw(18) << "LISTENING" << RESET
                     << YELLOW << setw(20) << port.service << RESET
                     << "\n";
            }
        }
    }
    
    // Statistics
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Connection Statistics                                                â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << "\n";
    cout << CYAN << "   Active Connections:      " << WHITE << dev.activeConnections.size() << RESET << "\n";
    cout << CYAN << "   Listening Ports:         " << WHITE << dev.listeningPorts.size() << RESET << "\n";
    
    if (!dev.interfaces.empty()) {
        cout << CYAN << "   Bytes Received:          " << WHITE << dev.interfaces[0].bytesReceived << RESET << "\n";
        cout << CYAN << "   Bytes Sent:              " << WHITE << dev.interfaces[0].bytesSent << RESET << "\n";
        cout << CYAN << "   Packets Received:        " << WHITE << dev.interfaces[0].packetsReceived << RESET << "\n";
        cout << CYAN << "   Packets Sent:            " << WHITE << dev.interfaces[0].packetsSent << RESET << "\n";
    }
    
    logToSyslog(INFO, NETWORK_MANAGEMENT, dev.id, dev.ipAddress,
               "NETSTAT_QUERY", "Network statistics queried by user", "user");
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARP TABLE - ADDRESS RESOLUTION PROTOCOL CACHE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void displayARPTable() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”— ARP - Address Resolution Protocol                â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Display IP-to-MAC address mappings from ARP cache                   â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., MGMT-PC1): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  ARP Cache for " << dev.name << string(55 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    if (deviceARPTables.find(deviceId) == deviceARPTables.end() || 
        deviceARPTables[deviceId].empty()) {
        cout << "\n" << YELLOW << "â„¹ï¸  ARP cache is empty. No entries found.\n" << RESET;
        return;
    }
    
    vector<ARPEntry>& arpTable = deviceARPTables[deviceId];
    
    cout << "\n" << CYAN << "Interface: " << WHITE << (dev.interfaces.empty() ? "Ethernet0" : dev.interfaces[0].interfaceName) << RESET << "\n\n";
    
    cout << left << CYAN
         << setw(18) << "Internet Address"
         << setw(20) << "Physical Address"
         << setw(12) << "Type"
         << setw(10) << "TTL"
         << RESET << "\n";
    cout << string(60, '-') << "\n";
    
    time_t now = time(0);
    
    for (const ARPEntry& entry : arpTable) {
        int remainingTTL = entry.ttl - (now - entry.timestamp);
        if (remainingTTL < 0) remainingTTL = 0;
        
        cout << left << WHITE
             << setw(18) << entry.ipAddress
             << GREEN << setw(20) << entry.macAddress << RESET;
        
        if (entry.type == "dynamic") {
            cout << YELLOW << setw(12) << "dynamic" << RESET;
        } else {
            cout << CYAN << setw(12) << "static" << RESET;
        }
        
        cout << WHITE << setw(10) << (to_string(remainingTTL) + "s") << RESET << "\n";
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total ARP Entries: " << YELLOW << arpTable.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    logToSyslog(INFO, NETWORK_MANAGEMENT, dev.id, dev.ipAddress,
               "ARP_QUERY", "ARP table queried by user", "user");
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRACEROUTE - TRACE PACKET PATH THROUGH NETWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED TRACEROUTE WITH ROUTING LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED TRACEROUTE WITH PROPER EXTERNAL SERVER HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… ADD DOXYGEN COMMENT (Line ~1850)
/**
 * @brief Performs network traceroute from source to destination
 * 
 * Traces the complete path packets take through the network using:
 * - Physical device connections
 * - Routing tables (for L3 devices)
 * - Firewall ACL checks
 * - NAT translation at FW-1
 * 
 * @details
 * - Uses BFS algorithm for path finding
 * - Supports both internal and external destinations
 * - Handles special cases (8.8.8.8, DMZ, ISP)
 * - Maximum 30 hops to prevent infinite loops
 * 
 * @pre Source device must exist in networkDevices
 * @post Updates globalTracerouteHistory with hop records
 * 
 * @complexity O(V + E) where V = devices, E = connections
 * 
 * @warning Loop detection using visited set
 * 
 * @see findPath(), calculateHopLatency(), performNAT()
 * 
 * @author Cloud TAP Team
 * @version 1.0.0
 */
void performTraceroute() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ—ºï¸  TRACEROUTE - Network Path Tracer                â•‘\n";
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    cout << WHITE;
    cout << "â•‘  Trace the route packets take using routing tables                   â•‘\n";
    cout << CYAN;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << YELLOW << "STEP 1: Select Source Device\n" << RESET;
    cout << WHITE << "Enter source device ID (e.g., MGMT-PC1): " << RESET;
    string sourceId;
    cin >> sourceId;
    
    if (networkDevices.find(sourceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Source device not found!\n" << RESET;
        return;
    }
    
    Device& sourceDev = networkDevices[sourceId];
    cout << GREEN << "âœ“ Source: " << WHITE << sourceDev.name << " (" << sourceDev.ipAddress << ")\n\n";
    
    cout << YELLOW << "STEP 2: Select Target\n" << RESET;
    cout << "  [1] Internal Device (by IP)\n";
    cout << "  [2] Google Server (8.8.8.8)\n";
    cout << "  [3] DMZ Server (172.16.0.10)\n";
    cout << "  [4] ISP Gateway (203.0.113.1)\n";
    cout << WHITE << "Choice: " << RESET;
    int targetChoice;
    cin >> targetChoice;
    
    string targetIP, targetName;
    
    if (targetChoice == 1) {
        cout << WHITE << "Enter target IP address: " << RESET;
        cin >> targetIP;
        targetName = "Internal Device";
    } else if (targetChoice == 2) {
        targetIP = "8.8.8.8";
        targetName = "Google DNS Server";
    } else if (targetChoice == 3) {
        targetIP = "172.16.0.10";
        targetName = "DMZ Server";
    } else if (targetChoice == 4) {
        targetIP = "203.0.113.1";
        targetName = "ISP Gateway";
    } else {
        cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
        return;
    }
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Tracing route to " << targetName << string(52 - targetName.length(), ' ') << "â•‘\n";
    cout << "â•‘  Target: " << targetIP << string(62 - targetIP.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    this_thread::sleep_for(chrono::milliseconds(500));
    
    // ========== REALISTIC PATH FINDING WITH PHYSICAL TOPOLOGY ==========
    globalTracerouteHistory.clear();
    vector<HopRecord> path;
    set<string> visited;
    string currentId = sourceId;
    int hopCount = 0;
    bool natApplied = false;
    string sourceIPAfterNAT = sourceDev.ipAddress;
    bool destinationReached = false;
    
    cout << "\n";
    cout << left << CYAN
         << setw(6) << "Hop"
         << setw(10) << "Latency"
         << setw(18) << "IP Address"
         << setw(35) << "Device Name"
         << setw(25) << "Next Device"
         << RESET << "\n";
    cout << string(94, '-') << "\n";
    
  // âœ… USE CONSTANT
while (hopCount < NetworkConstants::MAX_HOPS && !destinationReached) {
        // Loop detection
        if (visited.count(currentId)) {
            cout << RED << "\nâœ— Routing loop detected at " << currentId << "\n" << RESET;
            break;
        }
        visited.insert(currentId);
        
        // Get current device
        if (networkDevices.find(currentId) == networkDevices.end()) {
            cout << RED << "\nâœ— Device " << currentId << " not found\n" << RESET;
            break;
        }
        
        Device& currentDevice = networkDevices[currentId];
        hopCount++;
        
        // Calculate latency
        int latency = calculateHopLatency(currentDevice, targetIP);
        
        // Create hop record
        HopRecord hop;
        hop.hopNumber = hopCount;
        hop.deviceId = currentId;
        hop.deviceIP = currentDevice.ipAddress;
        hop.deviceName = currentDevice.name;
        hop.latency = latency;
        hop.reachable = true;
        
        path.push_back(hop);
        globalTracerouteHistory.push_back(hop);
        
        // Display hop
        cout << left << WHITE << setw(6) << hopCount;
        
        if (latency == 0) {
            cout << GREEN << setw(10) << "<1 ms" << RESET;
        } else {
            cout << GREEN << setw(10) << (to_string(latency) + " ms") << RESET;
        }
        
        cout << YELLOW << setw(18) << currentDevice.ipAddress << RESET
             << CYAN << setw(35) << currentDevice.name << RESET;
        
        // Check if destination reached
        if (currentDevice.ipAddress == targetIP) {
            cout << GREEN << setw(25) << "âœ“ DESTINATION" << RESET << "\n";
            cout << GREEN << "\nâœ“ Destination reached!\n" << RESET;
            destinationReached = true;
            break;
        }
        
        // ========== FIND NEXT HOP USING PHYSICAL CONNECTIONS ==========
        
        string nextDeviceId;
        string nextDeviceName;
        
        // For L2 switches and end devices, use physical connections
        if (currentDevice.type == L2_SWITCH || currentDevice.type == PC || 
            currentDevice.type == LAPTOP || currentDevice.type == SERVER ||
            currentDevice.type == EPHONE || currentDevice.type == ACCESS_POINT) {
            
            // Find uplink connection (usually to L3 switch or router)
            for (const Connection& conn : currentDevice.connections) {
                if (networkDevices.find(conn.targetDevice) != networkDevices.end()) {
                    Device& targetDev = networkDevices[conn.targetDevice];
                    // Prefer L3 devices for uplink
                    if (targetDev.type == L3_SWITCH || targetDev.type == ROUTER) {
                        nextDeviceId = conn.targetDevice;
                        nextDeviceName = targetDev.name;
                        break;
                    }
                }
            }
            
            // If no L3 uplink found, take first available connection
            if (nextDeviceId.empty() && !currentDevice.connections.empty()) {
                nextDeviceId = currentDevice.connections[0].targetDevice;
                if (networkDevices.find(nextDeviceId) != networkDevices.end()) {
                    nextDeviceName = networkDevices[nextDeviceId].name;
                }
            }
        }
        // For L3 devices (routers, L3 switches, firewalls), use routing table
        else {
            string nextHopIP = findNextHop(currentDevice, targetIP);
            
            if (nextHopIP.empty()) {
                cout << RED << setw(25) << "âœ— No route" << RESET << "\n";
                cout << RED << "\nâœ— No route to destination\n" << RESET;
                break;
            }
            
            nextDeviceId = findDeviceByIP(nextHopIP);
            
            // Special handling for external destinations
            if (nextDeviceId.empty()) {
                if (targetIP == "8.8.8.8" && currentId == "FW-1") {
                    nextDeviceId = "ISP-R1";
                } else if (targetIP == "172.16.0.10" && currentId == "FW-1") {
                    nextDeviceId = "DMZ-L3";
                }
            }
            
            if (!nextDeviceId.empty() && networkDevices.find(nextDeviceId) != networkDevices.end()) {
                nextDeviceName = networkDevices[nextDeviceId].name;
            }
        }
        
        // Check for NAT at firewall
        if (currentId == "FW-1" && !natApplied && targetIP.substr(0, 3) != "10.") {
            string publicIP = performNAT(sourceIPAfterNAT, "FW-1");
            sourceIPAfterNAT = publicIP;
            natApplied = true;
            
            cout << MAGENTA << "â†’ " << nextDeviceName << " [NAT]" << RESET << "\n";
            cout << "      " << YELLOW << "â”œâ”€ NAT: " << sourceDev.ipAddress 
                 << " â†’ " << publicIP << RESET << "\n";
        } else {
            cout << WHITE << "â†’ " << nextDeviceName << RESET << "\n";
        }
        
        this_thread::sleep_for(chrono::milliseconds(300));
        
        // ========== SPECIAL HANDLING FOR EXTERNAL SERVERS ==========
        
        if (targetIP == "8.8.8.8" && currentId == "ISP-R1") {
            // ISP-R1 â†’ EXT-R1
            hopCount++;
            cout << left << WHITE << setw(6) << hopCount
                 << GREEN << setw(10) << "8 ms" << RESET
                 << YELLOW << setw(18) << "8.8.8.1" << RESET
                 << CYAN << setw(35) << "External Router" << RESET
                 << WHITE << "â†’ Google DNS" << RESET << "\n";
            
            this_thread::sleep_for(chrono::milliseconds(300));
            
            // EXT-R1 â†’ GOOGLE
            hopCount++;
            cout << left << WHITE << setw(6) << hopCount
                 << GREEN << setw(10) << "12 ms" << RESET
                 << YELLOW << setw(18) << "8.8.8.8" << RESET
                 << CYAN << setw(35) << "Google DNS Server" << RESET
                 << GREEN << "âœ“ DESTINATION" << RESET << "\n";
            
            cout << GREEN << "\nâœ“ Destination reached!\n" << RESET;
            destinationReached = true;
            break;
        }
        
        if (targetIP == "172.16.0.10" && currentId == "DMZ-L3") {
            hopCount++;
            cout << left << WHITE << setw(6) << hopCount
                 << GREEN << setw(10) << "2 ms" << RESET
                 << YELLOW << setw(18) << "172.16.0.10" << RESET
                 << CYAN << setw(35) << "DMZ Server" << RESET
                 << GREEN << "âœ“ DESTINATION" << RESET << "\n";
            
            cout << GREEN << "\nâœ“ Destination reached!\n" << RESET;
            destinationReached = true;
            break;
        }
        
// âœ… FIXED: Add explicit destination check
        if (nextDeviceId.empty()) {
            if (!destinationReached) {
                cout << RED << "âœ— No route to destination (path broken)\n" << RESET;
            }
            break;
        }
        
        currentId = nextDeviceId;
    }
    
    if (hopCount >= 30) {
        cout << RED << "\nâœ— Maximum hop count reached\n" << RESET;
    }
    
    if (!destinationReached && hopCount < 30) {
        cout << RED << "\nâœ— Traceroute incomplete\n" << RESET;
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Trace complete\n";
    cout << "Total Hops: " << YELLOW << path.size() << RESET << "\n";
    if (natApplied) {
        cout << MAGENTA << "NAT Applied: " << WHITE << sourceDev.ipAddress 
             << " â†’ " << sourceIPAfterNAT << RESET << "\n";
    }
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    logToSyslog(INFO, NETWORK_MANAGEMENT, sourceDev.id, sourceDev.ipAddress,
               "TRACEROUTE_COMPLETED",
               "Traceroute to " + targetIP + " | Hops: " + to_string(path.size()),
               "user");
}

// External Servers Menu
void externalServersMenu() {
    while (true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                  ğŸŒ EXTERNAL SERVERS INTERFACE                        â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘  [1] Google DNS (8.8.8.8)                                             â•‘\n";
        cout << "â•‘  [2] DMZ Server (172.16.0.10)                                         â•‘\n";
        cout << "â•‘  [3] ISP Gateway (203.0.113.1)                                        â•‘\n";
        cout << "â•‘  [4] All Server Statistics                                            â•‘\n";
        cout << "â•‘  [0] Back                                                             â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        cout << CYAN << "External Servers >> " << RESET;
        int choice;
        cin >> choice;
        
        if (choice == 0) return;
        
        if (choice == 4) {
            system("clear");
            cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
            cout << "â•‘              ğŸ“Š ALL EXTERNAL SERVERS - STATISTICS                     â•‘\n";
            cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
            cout << RESET;
            
            for (auto& pair : externalServers) {
                ExternalServer& srv = pair.second;
                float successRate = srv.totalRequests > 0 ? 
                    (srv.successfulRequests * 100.0 / srv.totalRequests) : 0;
                
                cout << YELLOW << "â¤ " << srv.name << "\n" << RESET;
                cout << "  IP:         " << CYAN << srv.ipAddress << RESET << "\n";
                cout << "  Location:   " << srv.location << "\n";
                cout << "  Requests:   " << srv.totalRequests << " (" << GREEN 
                     << srv.successfulRequests << RESET << " success)\n\n";
            }
            
            cout << "\nPress Enter to continue...";
            cin.ignore();
            cin.get();
        }
    }
}

// Firewall ACL Viewer
void viewFirewallACLs() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”¥ FIREWALL ACL RULES                               â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    for (const ACLRule& rule : firewallACLs) {
        cout << CYAN << "Rule " << rule.ruleNumber << ": " << RESET;
        
        if (rule.action == "PERMIT") {
            cout << GREEN << "âœ“ PERMIT" << RESET;
        } else {
            cout << RED << "âœ— DENY" << RESET;
        }
        
        cout << " | " << rule.sourceNetwork << " â†’ " << rule.destinationNetwork << "\n";
        cout << "  " << WHITE << rule.description << RESET << "\n\n";
    }
}

// Network Tools Menu
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK TOOLS MENU - UPDATED VERSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void networkToolsMenu() {
    while (true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                  ğŸ› ï¸  NETWORK TOOLS (Simulation Mode)                  â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << GREEN << "ğŸŒ CONNECTIVITY TOOLS" << WHITE << "                                                  â•‘\n";
        cout << "â•‘  [1] Ping                      - Test reachability (ICMP)            â•‘\n";
        cout << "â•‘  [2] Traceroute                - Trace network path                  â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << YELLOW << "ğŸ“Š NETWORK STATUS TOOLS" << WHITE << "                                              â•‘\n";
        cout << "â•‘  [3] IPConfig                  - Show network configuration          â•‘\n";
        cout << "â•‘  [4] Netstat                   - Active connections & ports          â•‘\n";
        cout << "â•‘  [5] ARP Table                 - IP-to-MAC address mappings          â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << MAGENTA << "ğŸ“œ HISTORY & LOGS" << WHITE << "                                                    â•‘\n";
        cout << "â•‘  [6] Ping History              - View past ping results             â•‘\n";
        cout << "â•‘  [7] Traceroute History        - View past trace routes             â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << CYAN << "ğŸŒ EXTERNAL SERVERS" << WHITE << "                                                   â•‘\n";
        cout << "â•‘  [8] External Servers          - View external server stats         â•‘\n";
        cout << "â•‘  [9] Firewall ACL Rules        - View firewall configurations       â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  [0] Back to Main Menu                                               â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        cout << CYAN << "Network Tools >> " << RESET;
        int choice;
        cin >> choice;
        
        if (cin.fail()) {
            cin.clear();
            cin.ignore(10000, '\n');
            continue;
        }
        
        if (choice == 0) return;
        
        switch (choice) {
            case 1:
                performPing();
                break;
            case 2:
                performTraceroute();
                break;
            case 3:
                displayIPConfig();
                break;
            case 4:
                displayNetstat();
                break;
            case 5:
                displayARPTable();
                break;
            case 6:
                viewPingHistory();
                break;
            case 7:
                // View Traceroute History
                system("clear");
                cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
                cout << "â•‘                  ğŸ“Š TRACEROUTE HISTORY                                â•‘\n";
                cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
                cout << RESET;
                
                if (globalTracerouteHistory.empty()) {
                    cout << YELLOW << "No traceroute records. Perform a traceroute first!\n" << RESET;
                } else {
                    cout << GREEN << "Last Traceroute (" << globalTracerouteHistory.size() << " hops):\n\n" << RESET;
                    
                    for (const HopRecord& hop : globalTracerouteHistory) {
                        cout << CYAN << "Hop " << hop.hopNumber << ": " << RESET
                             << YELLOW << hop.deviceIP << RESET << " ("
                             << WHITE << hop.deviceName << RESET << ") - "
                             << GREEN << hop.latency << "ms" << RESET << "\n";
                    }
                }
                break;
            case 8:
                externalServersMenu();
                break;
            case 9:
                viewFirewallACLs();
                break;
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
                this_thread::sleep_for(chrono::seconds(1));
                continue;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTION 3: ROUTING & SWITCHING FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
void viewRoutingTable() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ“‹ ROUTING TABLE VIEWER                             â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., CORE-R1, L3-ACTIVE, FW-1): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    if (dev.routingTable.empty()) {
        cout << YELLOW << "\nâš ï¸  This device does not have a routing table (L2 device)\n" << RESET;
        return;
    }
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  Routing Table for " << dev.name << string(50 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << "\n";
    cout << left << CYAN
         << setw(20) << "Destination"
         << setw(18) << "Next Hop"
         << setw(25) << "Next Device"
         << setw(20) << "Interface"
         << setw(8) << "Metric"
         << setw(10) << "Protocol"
         << RESET << "\n";
    cout << string(101, '-') << "\n";
    
   // âœ… ADD SIZE CHECK
if (dev.routingTable.empty()) {
    cout << YELLOW << "\nâš ï¸ Routing table is empty\n" << RESET;
    return;
}

for (const RouteEntry& route : dev.routingTable) {
        if (!route.isActive) continue;
        
        cout << left << WHITE << setw(20) << route.destinationNetwork;
        
        // Next Hop IP
        if (route.nextHop == "0.0.0.0") {
            cout << GREEN << setw(18) << "Connected" << RESET;
            cout << GREEN << setw(25) << "(Directly attached)" << RESET;
        } else {
            cout << YELLOW << setw(18) << route.nextHop << RESET;
            
            // Find device name for this next hop
            string nextDeviceName = "Unknown";
            for (auto& pair : networkDevices) {
                if (pair.second.ipAddress == route.nextHop) {
                    nextDeviceName = pair.second.name;
                    break;
                }
            }
            // Check external servers
            if (route.nextHop == "8.8.8.1") nextDeviceName = "External Router";
            if (route.nextHop == "203.0.113.1") nextDeviceName = "ISP Router";
            if (route.nextHop == "172.16.0.1") nextDeviceName = "DMZ L3 Switch";
            
            cout << CYAN << setw(25) << ("â†’ " + nextDeviceName) << RESET;
        }
        
        cout << MAGENTA << setw(20) << route.outInterface << RESET
             << WHITE << setw(8) << route.metric << RESET;
        
        if (route.protocol == "Connected") {
            cout << GREEN << setw(10) << route.protocol << RESET;
        } else if (route.protocol == "OSPF") {
            cout << BLUE << setw(10) << route.protocol << RESET;
        } else if (route.protocol == "Static") {
            cout << YELLOW << setw(10) << route.protocol << RESET;
        }
        
        cout << "\n";
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total Routes: " << YELLOW << dev.routingTable.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    logToSyslog(INFO, NETWORK_MANAGEMENT, dev.id, dev.ipAddress,
               "ROUTING_TABLE_VIEWED", "Routing table queried", "user");
}
// Display DHCP Server Status - FIXED (Clean interface, correct allocated counts)
void displayDHCPServer() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘          DHCP SERVER STATUS (MGMT-SRV1: 10.10.10.10)                  â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
   // âœ… FIXED: Check BOTH service flag AND device status
    bool serverOnline = globalServices.dhcpOnline && 
                        (networkDevices.find("MGMT-SRV1") != networkDevices.end()) &&
                        (networkDevices["MGMT-SRV1"].status == ONLINE);
    
    if (serverOnline) {
        cout << GREEN << "âœ“ Server Status: OPERATIONAL\n" << RESET;
    } else {
        cout << RED << "ğŸ”´ Server Status: OFFLINE\n";
        cout << YELLOW << "âš ï¸  WARNING: DHCP services UNAVAILABLE!\n" << RESET;
    }
    
    int totalLeases = 0;
    for (auto& p : dhcpPools) {
        totalLeases += p.second.getUsedCount();
    }
    cout << CYAN << "  Total Leases: " << WHITE << totalLeases << "\n\n";
    
    cout << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<           "â•‘                    DHCP POOL STATUS                                â•‘\n";
    cout <<           "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    for (auto& p : dhcpPools) {
        int used = p.second.getUsedCount();
        int total = p.second.getTotalCount();
        
        cout << "\n" << YELLOW << "â¤ " << p.second.poolName << RESET;
        if (!serverOnline) cout << RED << " [SERVER OFFLINE]" << RESET;
        cout << "\n";
        
        cout << "  Subnet:    " << CYAN << p.second.subnet << RESET << "\n";
        cout << "  Allocated: ";
        
        if (serverOnline) {
            cout << GREEN << used << RESET << "/" << total << "\n";
        } else {
            cout << RED << used << " (ORPHANED)" << RESET << "/" << total << "\n";
        }
        
        if (!serverOnline && used > 0) {
            cout << YELLOW << "  âš ï¸  " << used << " leases ORPHANED\n" << RESET;
        }
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}
// HTTP Web Database Interface - FIXED (Shows ALL 48 devices)
void displayWebDatabase() {
    system("clear");
    
    displayLogo();
    
    cout << "\n" << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<                 "â•‘                  HTTP://10.10.10.10/DATABASE                          â•‘\n";
    cout <<                 "â•‘              CLOUD TAP WEB DATABASE INTERFACE                         â•‘\n";
    cout <<                 "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
    cout << YELLOW << "ğŸŒ Server:          " << WHITE << "MGMT-SRV1 (10.10.10.10)\n";
    cout << YELLOW << "ğŸ“Š Total Devices:   " << WHITE << networkDevices.size() << "\n";
    cout << YELLOW << "ğŸ”— Active Links:    " << WHITE << totalConnections << "\n";
    cout << YELLOW << "ğŸ”„ Last Updated:    " << WHITE << getCurrentTime() << " (Real-time)\n";
    cout << YELLOW << "ğŸ“¡ Status:          " << GREEN << "All Systems Operational\n\n" << RESET;
    
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                                        DEVICE DATABASE                                                     â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << left 
         << setw(13) << "ID" 
         << setw(28) << "Name" 
         << setw(13) << "Type" 
         << setw(18) << "IP Address" 
         << setw(10) << "VLAN" 
         << setw(15) << "Department" 
         << "Status\n";
    cout << string(110, '-') << "\n";
    for (auto& p : networkDevices) {
        Device& d = p.second;
        cout << left 
             << setw(13) << d.id 
             << setw(28) << (d.name.length() > 27 ? d.name.substr(0, 24) + "..." : d.name)
             << setw(13) << deviceIcon(d.type)
             << setw(18) << d.ipAddress 
             << setw(10) << d.vlan 
             << setw(15) << d.department;
        
        if (d.isActive) {
            cout << GREEN << "ğŸŸ¢ Online" << RESET;
        } else {
            cout << RED << "ğŸ”´ Offline" << RESET;
        }
        
        if (d.isDHCP) {
            cout << YELLOW << " [DHCP]" << RESET;
        }
        cout << "\n";
    }
    
    cout << "\n" << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<                 "â•‘                   WEB INTERFACE FEATURES                           â•‘\n";
    cout <<                 "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    cout << GREEN << "  âœ“ " << WHITE << "Real-time device monitoring and status tracking\n";
    cout << GREEN << "  âœ“ " << WHITE << "Network topology visualization (graphical)\n";
    cout << GREEN << "  âœ“ " << WHITE << "DHCP lease information and pool management\n";
    cout << GREEN << "  âœ“ " << WHITE << "Connection status and link monitoring\n";
    cout << GREEN << "  âœ“ " << WHITE << "Department-wise device filtering\n";
    cout << GREEN << "  âœ“ " << WHITE << "Search functionality (by IP, name, type)\n";
    cout << GREEN << "  âœ“ " << WHITE << "Historical data and analytics\n" << RESET;
}

// Email Server Interface - FIXED (View Only, no sending here)
void viewEmailInbox() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                      EMAIL SERVER - INBOX                             â•‘\n";
    cout <<         "â•‘                   MGMT-SRV1: 10.10.10.10                              â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
    if (emailInbox.empty()) {
        cout << YELLOW << "No emails in inbox.\n" << RESET;
    } else {
        for (size_t i = 0; i < emailInbox.size(); i++) {
            Email& e = emailInbox[i];
            cout << (e.isRead ? WHITE : YELLOW) << "[" << (i+1) << "] ";
            if (!e.isRead) cout << "ğŸ“© NEW ";
            cout << CYAN << "From: " << WHITE << e.from << "\n";
            cout << CYAN << "    To: " << WHITE << e.to << "\n";
            cout << CYAN << "    Subject: " << WHITE << e.subject << "\n";
            cout << CYAN << "    Time: " << WHITE << e.timestamp << "\n";
            cout << CYAN << "    Message: " << WHITE << e.body << "\n\n" << RESET;
        }
    }
}

// IP Phone System - FIXED (Moved to Server Management)
void viewPhoneDirectory() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                  IP PHONE SERVER - DIRECTORY                          â•‘\n";
    cout <<         "â•‘                   Voice Router: 10.10.60.254                          â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
    cout << YELLOW << "Internal Extensions (VLAN 60 - 10.10.60.0/24):\n\n" << RESET;
    for (auto& p : phoneDirectory) {
        cout << GREEN << "  â˜ Extension: " << CYAN << p.first << RESET << "\n";
        cout << WHITE << "     " << p.second << "\n\n" << RESET;
    }
}

void viewCallLogs() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                  IP PHONE SERVER - CALL LOGS                          â•‘\n";
    cout <<         "â•‘                   Voice Router: 10.10.60.254                          â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
    
    if (callLogs.empty()) {
        cout << YELLOW << "No call logs available.\n" << RESET;
    } else {
        for (size_t i = 0; i < callLogs.size(); i++) {
            CallLog& c = callLogs[i];
            cout << CYAN << "[" << (i+1) << "] " << WHITE << c.timestamp << "\n";
            cout << GREEN << "    To: " << WHITE << c.to << "\n";
            cout << GREEN << "    Duration: " << WHITE << c.duration << "\n\n" << RESET;
        }
    }
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYSLOG SERVER INTERFACE - ADD AFTER viewCallLogs()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void displaySyslogStats() {
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘               SYSLOG SERVER STATISTICS                 â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << CYAN << "  Total Events:     " << WHITE << syslogStats.totalEvents << "\n";
    cout << CYAN << "  Database Size:    " << WHITE << syslogDatabase.size() << " / " 
         << MAX_SYSLOG_ENTRIES << " entries\n\n";
    
    cout << YELLOW << "Severity Breakdown:\n" << RESET;
    cout << RED     << "  ğŸ”´ EMERGENCY:   " << WHITE << syslogStats.emergencyCount << "\n";
    cout << RED     << "  ğŸ”´ ALERT:       " << WHITE << syslogStats.alertCount << "\n";
    cout << MAGENTA << "  ğŸŸ£ CRITICAL:    " << WHITE << syslogStats.criticalCount << "\n";
    cout << MAGENTA << "  ğŸŸ£ ERROR:       " << WHITE << syslogStats.errorCount << "\n";
    cout << YELLOW  << "  ğŸŸ¡ WARNING:     " << WHITE << syslogStats.warningCount << "\n";
    cout << CYAN    << "  ğŸ”µ NOTICE:      " << WHITE << syslogStats.noticeCount << "\n";
    cout << GREEN   << "  ğŸŸ¢ INFO:        " << WHITE << syslogStats.infoCount << "\n";
    cout << WHITE   << "  âšª DEBUG:       " << WHITE << syslogStats.debugCount << "\n";
}

void viewRecentLogs(int count = 50) {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                  SYSLOG SERVER - RECENT EVENTS                       â•‘\n";
    cout << "â•‘                   MGMT-SRV1: 10.10.10.10                             â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    if (syslogDatabase.empty()) {
        cout << YELLOW << "Syslog database is empty. No events recorded yet.\n" << RESET;
        return;
    }
    
    displaySyslogStats();
    
    cout << "\n" << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "                    RECENT LOG ENTRIES (Last " << count << ")                    \n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    int displayed = 0;
    
    for (auto it = syslogDatabase.rbegin(); 
         it != syslogDatabase.rend() && displayed < count; 
         ++it, ++displayed) {
        
        cout << it->getSeverityColor() << "[" << it->getSeverityString() << "] " << RESET
             << CYAN << it->timestamp << RESET << " | "
             << YELLOW << it->getFacilityString() << RESET << "\n";
        cout << "  Device:   " << WHITE << it->sourceDevice << RESET << " (" << it->sourceIP << ")\n";
        cout << "  Event:    " << WHITE << it->eventType << RESET << "\n";
        cout << "  Message:  " << WHITE << it->message << RESET << "\n";
        cout << "  User:     " << WHITE << it->username << RESET << "\n\n";
    }
    
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Showing " << displayed << " of " << syslogDatabase.size() << " total entries\n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

void syslogServerMenu() {
    while (true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                      SYSLOG SERVER INTERFACE                          â•‘\n";
        cout << "â•‘                   MGMT-SRV1: 10.10.10.10:514                          â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘  [1] View Recent Logs (Last 50)                                       â•‘\n";
        cout << "â•‘  [2] View All Logs (Last 100)                                         â•‘\n";
        cout << "â•‘  [3] View Statistics Only                                             â•‘\n";
        cout << "â•‘  [0] Back to Server Management                                        â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        cout << CYAN << "Syslog Server >> " << RESET;
        int choice;
        cin >> choice;
        
        if (cin.fail()) {
            cin.clear();
            cin.ignore(10000, '\n');
            continue;
        }
        
        if (choice == 0) return;
        
        switch (choice) {
            case 1:
                viewRecentLogs(50);
                break;
            case 2:
                viewRecentLogs(100);
                break;
            case 3:
                system("clear");
                displaySyslogStats();
                break;
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
                this_thread::sleep_for(chrono::seconds(1));
                continue;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
}
// Server Management Menu - FIXED (HTTP, DHCP, Email View, Phone Server)
void serverManagementMenu() {
    while(true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout <<         "â•‘                    SERVER MANAGEMENT                                  â•‘\n";
        cout <<         "â•‘                   MGMT-SRV1: 10.10.10.10                              â•‘\n";
        cout <<         "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout <<         "â•‘  [1] HTTP Web Database Interface                                      â•‘\n";
        cout <<         "â•‘  [2] DHCP Server Status                                               â•‘\n";
        cout <<         "â•‘  [3] Email Server (View Inbox)                                        â•‘\n";
        cout <<         "â•‘  [4] IP Phone Server (Directory & Call Logs)                          â•‘\n";
        cout <<         "â•‘  [5] Syslog Server (Event Monitor & Logs)                             â•‘\n";
        cout <<         "â•‘  [0] Back to Network Management                                       â•‘\n";
        cout << CYAN;
        cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        cout << CYAN << "Server Management >> " << RESET;
        int choice;
        cin >> choice;
        
        if (cin.fail()) {
            cin.clear();
            cin.ignore(10000, '\n');
            continue;
        }
        
        if (choice == 0) return;
        
        switch(choice) {
            case 1:
                displayWebDatabase();
                break;
            case 2:
                displayDHCPServer();
                break;
            case 3:
                viewEmailInbox();
                break;
            case 4: {
                while(true) {
                    system("clear");
                    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
                    cout <<         "â•‘                    IP PHONE SERVER MENU                               â•‘\n";
                    cout <<         "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
                    cout << WHITE;
                    cout <<         "â•‘  [1] View Phone Directory                                             â•‘\n";
                    cout <<         "â•‘  [2] View Call Logs                                                   â•‘\n";
                    cout <<         "â•‘  [0] Back                                                             â•‘\n";
                    cout << CYAN;
                    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
                    cout << RESET;
                    
                    cout << CYAN << "Phone Server >> " << RESET;
                    int phoneChoice;
                    cin >> phoneChoice;
                    
                    if (phoneChoice == 0) break;
                    else if (phoneChoice == 1) viewPhoneDirectory();
                    else if (phoneChoice == 2) viewCallLogs();
                    
                    cout << "\nPress Enter to continue...";
                    cin.ignore();
                    cin.get();
                }
                break;
            }case 5:
                syslogServerMenu();
                break;
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
}

// Show All Devices
void showAllDevices() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                   ALL NETWORK DEVICES                                 â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    int onlineCount = 0, offlineCount = 0;
    for (auto& pair : networkDevices) {
        if (pair.second.status == ONLINE) onlineCount++;
        else offlineCount++;
    }
    
    cout << YELLOW << "Network Status: " << RESET;
    cout << GREEN << onlineCount << " Online" << RESET << " | ";
    cout << RED << offlineCount << " Offline" << RESET << "\n\n";
    
    if (!globalServices.dhcpOnline || !globalServices.emailOnline || !globalServices.webOnline) {
        cout << RED << "âš ï¸  CRITICAL SERVICES OFFLINE:\n" << RESET;
        if (!globalServices.dhcpOnline) cout << RED << "   âŒ DHCP Service\n" << RESET;
        if (!globalServices.emailOnline) cout << RED << "   âŒ Email Service\n" << RESET;
        if (!globalServices.webOnline) cout << RED << "   âŒ Web Service\n" << RESET;
        cout << "\n";
    }
    
    cout << left 
         << setw(13) << "ID" 
         << setw(28) << "Name" 
         << setw(13) << "Type" 
         << setw(18) << "IP" 
         << setw(10) << "VLAN" 
         << setw(20) << "Status"
         << "Reason\n";
    cout << string(120, '-') << "\n";
    
    map<string, vector<string>> deptDevices;
    for (auto& pair : networkDevices) {
        deptDevices[pair.second.department].push_back(pair.first);
    }
    
    vector<string> deptOrder = {"Internet", "Security", "DMZ", "Core", "Voice", "Wireless",
                                "Management", "IT", "Sales", "Finance", "HR"};
    
    for (const string& deptName : deptOrder) {
        if (deptDevices.find(deptName) == deptDevices.end()) continue;
        
        int deptOnline = 0, deptOffline = 0;
        for (const string& devId : deptDevices[deptName]) {
            if (networkDevices[devId].status == ONLINE) deptOnline++;
            else deptOffline++;
        }
        
        cout << "\n" << YELLOW << "[" << deptName << "] " << RESET;
        if (deptOffline > 0) {
            cout << RED << "âš ï¸  " << deptOffline << "/" << (deptOnline + deptOffline) << " OFFLINE" << RESET;
        } else {
            cout << GREEN << "âœ… All Online" << RESET;
        }
        cout << "\n\n";
        
        for (const string& devId : deptDevices[deptName]) {
            Device& dev = networkDevices[devId];
            
            cout << left 
                 << setw(13) << dev.id 
                 << setw(28) << (dev.name.length() > 27 ? dev.name.substr(0, 24) + "..." : dev.name)
                 << setw(13) << deviceIcon(dev.type)
                 << setw(18) << dev.ipAddress 
                 << setw(10) << dev.vlan
                 << setw(20) << deviceStatusToString(dev.status);
            
            if (dev.status != ONLINE) {
                cout << WHITE << dev.offlineReason << RESET;
            } else {
                cout << WHITE << "Normal operation" << RESET;
            }
            
            if (dev.isDHCP) cout << YELLOW << " [DHCP]" << RESET;
            if (dev.isCriticalService) cout << RED << " [CRITICAL]" << RESET;
            cout << "\n";
        }
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total: " << networkDevices.size() << " | ";
    cout << GREEN << "Online: " << onlineCount << RESET << " | ";
    cout << RED << "Offline: " << offlineCount << RESET << "\n";
    cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}
// Connect Devices
void connectDevices() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout <<         "â•‘                         CONNECT DEVICES                               â•‘\n";
    cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    string fromId, toId, protocol;
    
    cout << WHITE << "Enter Source Device ID: " << RESET;
    cin >> fromId;
    
    if (networkDevices.find(fromId) == networkDevices.end()) {
        cout << RED << "\n[ERROR] Source device not found!\n" << RESET;
        return;
    }
    
    cout << WHITE << "Enter Target Device ID: " << RESET;
    cin >> toId;
    
    if (networkDevices.find(toId) == networkDevices.end()) {
        cout << RED << "\n[ERROR] Target device not found!\n" << RESET;
        return;
    }
    
    cin.ignore();
    cout << WHITE << "Enter Protocol (e.g., OSPF, Ethernet, Trunk, Access): " << RESET;
    getline(cin, protocol);
    
    networkDevices[fromId].connections.push_back({toId, protocol});
    networkDevices[toId].connections.push_back({fromId, protocol});
      // â¬…ï¸ ADD THIS LINE HERE
    logToSyslog(NOTICE, NETWORK_MANAGEMENT, fromId, 
               networkDevices[fromId].ipAddress, "LINK_ESTABLISHED",
               "Connection: " + fromId + " â†â†’ " + toId + " | Protocol: " + protocol, "admin");
    
    cout << GREEN << "\nâœ“ Devices connected successfully!\n" << RESET;
    cout << CYAN << fromId << " â†â†’ " << toId << " (" << protocol << ")\n" << RESET;
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NETWORK ANALYSIS MODULE - Option 5
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NetworkAnalyzer {
public:
    // Main analysis functions
    static void analyzeNetworkHealth() {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘              NETWORK HEALTH ANALYSIS                          â•‘\n";
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        // Count online/offline devices
        int online = 0, offline = 0;
        for (auto& pair : networkDevices) {
            if (pair.second.status == ONLINE) online++;
            else offline++;
        }
        
        // Calculate health score
        int healthScore = (online * 100) / (online + offline);
        
        cout << YELLOW << "ğŸ“Š Overall Health Score: " << WHITE;
        if (healthScore >= 90) cout << GREEN << healthScore << "/100 â­â­â­â­â­" << RESET;
        else if (healthScore >= 75) cout << GREEN << healthScore << "/100 â­â­â­â­" << RESET;
        else if (healthScore >= 50) cout << YELLOW << healthScore << "/100 â­â­â­" << RESET;
        else cout << RED << healthScore << "/100 â­â­" << RESET;
        cout << "\n\n";
        
        cout << GREEN << "âœ… Online Devices:     " << WHITE << online << "/" << (online+offline) 
             << " (" << (online*100)/(online+offline) << "%)\n";
        cout << (offline > 0 ? RED : GREEN) << "âš ï¸  Offline Devices:   " << WHITE << offline 
             << "/" << (online+offline) << " (" << (offline*100)/(online+offline) << "%)\n";
        
        // Critical services check
        cout << "\n" << YELLOW << "Critical Services Status:\n" << RESET;
        cout << (globalServices.dhcpOnline ? GREEN "  âœ… DHCP:  OPERATIONAL\n" : RED "  âŒ DHCP:  OFFLINE\n") << RESET;
        cout << (globalServices.emailOnline ? GREEN "  âœ… Email: OPERATIONAL\n" : RED "  âŒ Email: OFFLINE\n") << RESET;
        cout << (globalServices.webOnline ? GREEN "  âœ… Web:   OPERATIONAL\n" : RED "  âŒ Web:   OFFLINE\n") << RESET;
        
        // Department health
        cout << "\n" << YELLOW << "Department Health:\n" << RESET;
        map<string, pair<int,int>> deptStats; // dept -> (online, total)
        
        for (auto& pair : networkDevices) {
            string dept = pair.second.department;
            if (dept == "Core" || dept == "Internet" || dept == "Security" || dept == "DMZ" || 
                dept == "Voice" || dept == "Wireless") continue;
            
            deptStats[dept].second++; // total
            if (pair.second.status == ONLINE) deptStats[dept].first++; // online
        }
        
        for (auto& ds : deptStats) {
            int pct = (ds.second.first * 100) / ds.second.second;
            cout << "  " << left << setw(12) << ds.first << ": ";
            if (pct == 100) cout << GREEN << "âœ… 100%";
            else if (pct >= 80) cout << YELLOW << "âš ï¸  " << pct << "%";
            else cout << RED << "ğŸ”´ " << pct << "%";
            cout << WHITE << " (" << ds.second.first << "/" << ds.second.second << " online)" << RESET << "\n";
        }
    }
    
    static void analyzeDHCPUtilization() {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘              DHCP POOL UTILIZATION ANALYSIS                   â•‘\n";
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        for (auto& p : dhcpPools) {
            int used = p.second.getUsedCount();
            int total = p.second.getTotalCount();
            int pct = (used * 100) / total;
            
            cout << YELLOW << "â¤ " << left << setw(18) << p.second.poolName << RESET;
            
            // Progress bar
            int barLength = 10;
            int filled = (pct * barLength) / 100;
            cout << " [";
            for (int i = 0; i < barLength; i++) {
                if (i < filled) {
                    if (pct >= 80) cout << RED << "â–ˆ";
                    else if (pct >= 60) cout << YELLOW << "â–ˆ";
                    else cout << GREEN << "â–ˆ";
                } else {
                    cout << WHITE << "â–‘";
                }
            }
            cout << RESET << "] ";
            
            if (pct >= 80) cout << RED << pct << "%";
            else if (pct >= 60) cout << YELLOW << pct << "%";
            else cout << GREEN << pct << "%";
            
            cout << WHITE << " (" << used << "/" << total << " IPs)\n" << RESET;
        }
        
        cout << "\n" << YELLOW << "Recommendations:\n" << RESET;
        for (auto& p : dhcpPools) {
            int pct = (p.second.getUsedCount() * 100) / p.second.getTotalCount();
            if (pct >= 80) {
                cout << RED << "  âš ï¸  " << p.second.poolName << ": " << pct 
                     << "% utilized - RECOMMEND EXPANSION\n" << RESET;
            }
        }
    }
    
    static void detectBottlenecks() {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘              NETWORK BOTTLENECK DETECTION                     â•‘\n";
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        // Find most connected devices
        vector<pair<string, int>> connectionCounts;
        for (auto& pair : networkDevices) {
            connectionCounts.push_back(make_pair(pair.first, (int)pair.second.connections.size()));
        }
        
        // âœ… FIXED: C++11 compatible sort (no auto in lambda)
        sort(connectionCounts.begin(), connectionCounts.end(), 
             [](const pair<string,int>& a, const pair<string,int>& b) { 
                 return a.second > b.second; 
             });
        
        cout << YELLOW << "Most Connected Devices (Potential Bottlenecks):\n\n" << RESET;
        
        for (int i = 0; i < min(5, (int)connectionCounts.size()); i++) {
            Device& dev = networkDevices[connectionCounts[i].first];
            cout << "  " << (i+1) << ". " << CYAN << left << setw(15) << dev.name << RESET;
            cout << WHITE << connectionCounts[i].second << " connections" << RESET;
            
            if (connectionCounts[i].second >= 10) {
                cout << RED << " âš ï¸  HIGH LOAD" << RESET;
            }
            cout << "\n";
        }
        
        cout << "\n" << YELLOW << "Single Points of Failure:\n" << RESET;
        cout << RED << "  ğŸ”´ MGMT-SRV1: Hosts all critical services (DHCP, Email, Web)\n";
        cout << "  ğŸ”´ FW-1: Single firewall (no redundancy)\n" << RESET;
        cout << YELLOW << "  ğŸŸ¡ Each department L2 switch (no backup)\n" << RESET;
    }
    
    static void generateComprehensiveReport() {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘          COMPREHENSIVE NETWORK REPORT                         â•‘\n";
        cout << "â•‘          Generated: " << getCurrentTime() << "                    â•‘\n";
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        // All analysis in one place
        analyzeNetworkHealth();
        cout << "\n" << string(65, '=') << "\n\n";
        analyzeDHCPUtilization();
        cout << "\n" << string(65, '=') << "\n\n";
        detectBottlenecks();
        
        cout << "\n\n" << GREEN << "âœ… Report generated successfully!\n" << RESET;
    }
};

void networkAnalysisMenu() {
    while (true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                  ğŸ“Š NETWORK ANALYSIS MODULE                           â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  [1] Network Health Dashboard      - Overall network status          â•‘\n";
        cout << "â•‘  [2] DHCP Utilization Analysis     - Pool usage & recommendations    â•‘\n";
        cout << "â•‘  [3] Bottleneck Detection          - Identify performance issues     â•‘\n";
        cout << "â•‘  [4] Device Distribution Analysis  - Device type breakdown           â•‘\n";
        cout << "â•‘  [5] Traffic Pattern Analysis      - Connection analysis             â•‘\n";
        cout << "â•‘  [6] Security Posture Report       - Firewall & ACL analysis         â•‘\n";
        cout << "â•‘  [7] Generate Comprehensive Report - All analyses combined           â•‘\n";
        cout << "â•‘  [0] Back to Main Menu                                               â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        int choice = getValidatedInt(CYAN "Network Analysis >> " RESET, 0, 7);
        
        if (choice == 0) return;
        
        switch (choice) {
            case 1:
                NetworkAnalyzer::analyzeNetworkHealth();
                break;
            case 2:
                NetworkAnalyzer::analyzeDHCPUtilization();
                break;
            case 3:
                NetworkAnalyzer::detectBottlenecks();
                break;
            case 7:
                NetworkAnalyzer::generateComprehensiveReport();
                break;
            default:
                cout << YELLOW << "\n[!] Feature coming soon...\n" << RESET;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
}
// Network Management Menu
void networkManagementMenu() {
    while(true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout <<         "â•‘                      NETWORK MANAGEMENT MODULE                        â•‘\n";
        cout <<         "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout <<         "â•‘                                                                       â•‘\n";
        cout <<         "â•‘  [1] Display Network Topology                                         â•‘\n";
        cout <<         "â•‘  [2] Add Device (Smart DHCP)                                          â•‘\n";
        cout <<         "â•‘  [3] Remove Device                                                    â•‘\n";
        cout <<         "â•‘  [4] Connect Devices                                                  â•‘\n";
        cout <<         "â•‘  [5] Show All Devices                                                 â•‘\n";
        cout <<         "â•‘  [6] Search Devices (Advanced)                                        â•‘\n";  // â¬…ï¸ NEW
        cout <<         "â•‘  [7] Server Management (HTTP/DHCP/EMAIL/PHONE)                        â•‘\n";  // â¬…ï¸ CHANGED
        cout <<         "â•‘  [0] Back to Main Menu                                                â•‘\n";    
        cout <<         "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout <<         "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
       // âœ… ALREADY HAS ERROR HANDLING - BUT IMPROVE IT
cout << CYAN << "Cloud TAP (Network Management) >> " << RESET;
int choice;
cin >> choice;

if (cin.fail()) {
    cin.clear();
    cin.ignore(10000, '\n');
    cout << RED << "âŒ Invalid input! Enter 0-7\n" << RESET;  // âœ… ADD MESSAGE
    this_thread::sleep_for(chrono::seconds(1));  // âœ… ADD PAUSE
    continue;
}
        
        switch(choice) {
            case 0:
                return;
            case 1:
                displayTopology();
                break;
            case 2:
                addDeviceSmart();
                break;
            case 3:
                removeDevice();
                break;
            case 4:
                connectDevices();
                break;
           case 5:
                showAllDevices();
                break;
            case 6:                      // â¬…ï¸ NEW CASE
                searchDeviceMenu();
                break;
            case 7:                      // â¬…ï¸ CHANGED FROM 6 TO 7
                serverManagementMenu();
                break;
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTING & SWITCHING MENU - ADD AFTER networkManagementMenu()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void viewVLANConfiguration() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ“‹ VLAN CONFIGURATION                               â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., L3-ACTIVE, MGMT-SW1): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    if (dev.vlans.empty()) {
        cout << YELLOW << "\nâš ï¸  This device has no VLAN configuration\n" << RESET;
        return;
    }
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  VLANs configured on " << dev.name << string(49 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << "\n";
    cout << left << CYAN
         << setw(10) << "VLAN ID"
         << setw(20) << "Name"
         << setw(20) << "Subnet"
         << setw(12) << "Status"
         << RESET << "\n";
    cout << string(62, '-') << "\n";
    
    for (const VLANConfig& vlan : dev.vlans) {
        cout << left << WHITE
             << setw(10) << vlan.vlanId
             << YELLOW << setw(20) << vlan.vlanName << RESET
             << CYAN << setw(20) << vlan.subnet << RESET;
        
        if (vlan.isActive) {
            cout << GREEN << setw(12) << "Active" << RESET;
        } else {
            cout << RED << setw(12) << "Inactive" << RESET;
        }
        cout << "\n";
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total VLANs: " << YELLOW << dev.vlans.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

void viewTrunkLinks() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”— TRUNK LINKS CONFIGURATION                        â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    if (globalTrunkLinks.empty()) {
        cout << YELLOW << "No trunk links configured\n" << RESET;
        return;
    }
    
    cout << left << CYAN
         << setw(15) << "Local Device"
         << setw(18) << "Local Interface"
         << setw(15) << "Remote Device"
         << setw(18) << "Remote Interface"
         << setw(12) << "Status"
         << RESET << "\n";
    cout << string(78, '-') << "\n";
    
    for (const TrunkLink& trunk : globalTrunkLinks) {
        cout << left << WHITE
             << setw(15) << trunk.localDevice
             << CYAN << setw(18) << trunk.localInterface << RESET
             << WHITE << setw(15) << trunk.remoteDevice
             << CYAN << setw(18) << trunk.remoteInterface << RESET;
        
        if (trunk.isActive) {
            cout << GREEN << "Active" << RESET;
        } else {
            cout << RED << "Down" << RESET;
        }
        
        cout << "\n";
        cout << "  VLANs: ";
        for (size_t i = 0; i < trunk.allowedVLANs.size(); i++) {
            cout << YELLOW << trunk.allowedVLANs[i];
            if (i < trunk.allowedVLANs.size() - 1) cout << ",";
        }
        cout << RESET << "\n\n";
    }
    
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total Trunk Links: " << YELLOW << globalTrunkLinks.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

void viewOSPFStatus() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”„ OSPF ROUTING PROTOCOL STATUS                     â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << WHITE << "Enter Device ID (e.g., CORE-R1, L3-ACTIVE): " << RESET;
    string deviceId;
    cin >> deviceId;
    
    if (networkDevices.find(deviceId) == networkDevices.end()) {
        cout << RED << "\nâŒ [ERROR] Device not found!\n" << RESET;
        return;
    }
    
    Device& dev = networkDevices[deviceId];
    
    if (dev.ospfNeighbors.empty()) {
        cout << YELLOW << "\nâš ï¸  No OSPF neighbors configured\n" << RESET;
        return;
    }
    
    cout << "\n" << YELLOW << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘  OSPF Neighbors on " << dev.name << string(51 - dev.name.length(), ' ') << "â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
    
    cout << "\n";
    cout << left << CYAN
         << setw(18) << "Neighbor IP"
         << setw(30) << "Neighbor Device"
         << setw(20) << "Interface"
         << setw(12) << "State"
         << RESET << "\n";
    cout << string(80, '-') << "\n";
    
    for (const OSPFNeighbor& neighbor : dev.ospfNeighbors) {
        cout << left << YELLOW << setw(18) << neighbor.neighborIP << RESET;
        
        // Find device name
        string deviceName = "Unknown";
        for (auto& pair : networkDevices) {
            if (pair.second.ipAddress == neighbor.neighborIP) {
                deviceName = pair.second.name;
                break;
            }
        }
        
        cout << CYAN << setw(30) << ("â†’ " + deviceName) << RESET
             << MAGENTA << setw(20) << neighbor.interface_ << RESET;
        
        if (neighbor.state == "FULL") {
            cout << GREEN << neighbor.state << " âœ“" << RESET;
        } else {
            cout << YELLOW << neighbor.state << RESET;
        }
        
        cout << "\n";
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total OSPF Neighbors: " << YELLOW << dev.ospfNeighbors.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

void viewNATTable() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”€ NAT TRANSLATION TABLE (FW-1)                     â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    if (natTables.find("FW-1") == natTables.end() || natTables["FW-1"].empty()) {
        cout << YELLOW << "âš ï¸  No active NAT translations\n\n" << RESET;
        cout << CYAN << "NAT translations are created when:\n" << RESET;
        cout << WHITE << "  1. Internal device communicates with external network\n";
        cout << "  2. Traffic passes through firewall (FW-1)\n";
        cout << "  3. Destination is outside private network (8.8.8.8, etc.)\n\n";
        cout << GREEN << "ğŸ’¡ Tip: " << WHITE << "Run a ping or traceroute to 8.8.8.8 first\n" << RESET;
        return;
    }
    
    vector<NATEntry>& table = natTables["FW-1"];
    
    cout << left << CYAN
         << setw(18) << "Inside Local"
         << setw(18) << "Inside Global"
         << setw(12) << "Protocol"
         << setw(12) << "State"
         << setw(10) << "Age"
         << RESET << "\n";
    cout << string(70, '-') << "\n";
    
    time_t now = time(0);
    
    for (const NATEntry& entry : table) {
        int age = now - entry.timestamp;
        
        cout << left << YELLOW << setw(18) << entry.insideLocal << RESET
             << GREEN << setw(18) << entry.insideGlobal << RESET
             << WHITE << setw(12) << entry.protocol << RESET;
        
        if (age < 300) {
            cout << GREEN << setw(12) << "Active" << RESET;
        } else {
            cout << YELLOW << setw(12) << "Expired" << RESET;
        }
        
        cout << WHITE << age << "s" << RESET << "\n";
    }
    
    cout << "\n" << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    cout << "Total NAT Entries: " << YELLOW << table.size() << RESET << "\n";
    cout << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << RESET;
}

void viewHSRPStatus() {
    system("clear");
    cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    cout << "â•‘                   ğŸ”„ HSRP STATUS (Redundancy Protocol)                â•‘\n";
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    cout << RESET;
    
    cout << YELLOW << "Hot Standby Router Protocol Configuration:\n\n" << RESET;
    
    // L3-ACTIVE
    if (networkDevices.find("L3-ACTIVE") != networkDevices.end()) {
        HSRPStatus& hsrp = networkDevices["L3-ACTIVE"].hsrpStatus;
        
        cout << CYAN << "Device: " << WHITE << "L3-ACTIVE\n";
        cout << CYAN << "  Virtual IP:  " << YELLOW << hsrp.virtualIP << RESET << "\n";
        cout << CYAN << "  State:       " << GREEN << "âš« " << hsrp.state << RESET << "\n";
        cout << CYAN << "  Priority:    " << WHITE << hsrp.priority << RESET << "\n";
        cout << CYAN << "  Preempt:     " << WHITE << hsrp.preempt << RESET << "\n\n";
    }
    
    // L3-STANDBY
    if (networkDevices.find("L3-STANDBY") != networkDevices.end()) {
        HSRPStatus& hsrp = networkDevices["L3-STANDBY"].hsrpStatus;
        
        cout << CYAN << "Device: " << WHITE << "L3-STANDBY\n";
        cout << CYAN << "  Virtual IP:  " << YELLOW << hsrp.virtualIP << RESET << "\n";
        cout << CYAN << "  State:       " << YELLOW << "âšª " << hsrp.state << RESET << "\n";
        cout << CYAN << "  Priority:    " << WHITE << hsrp.priority << RESET << "\n";
        cout << CYAN << "  Preempt:     " << WHITE << hsrp.preempt << RESET << "\n\n";
    }
    
    cout << GREEN << "âœ“ HSRP provides gateway redundancy\n";
    cout << "âœ“ Virtual Gateway: 10.10.0.254 (Shared by both L3 switches)\n" << RESET;
}

void routingAndSwitchingMenu() {
    while (true) {
        system("clear");
        cout << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                  ğŸ”€ ROUTING & SWITCHING MODULE                        â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << GREEN << "ğŸ“Š ROUTING TABLES" << WHITE << "                                                      â•‘\n";
        cout << "â•‘  [1] View Routing Table           - Show device routing table        â•‘\n";
        cout << "â•‘  [2] View OSPF Status             - OSPF neighbor & routes           â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << YELLOW << "ğŸ”— SWITCHING & VLANs" << WHITE << "                                                 â•‘\n";
        cout << "â•‘  [3] View VLAN Configuration      - Show VLAN assignments            â•‘\n";
        cout << "â•‘  [4] View Trunk Links             - Display trunk connections        â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  " << MAGENTA << "ğŸŒ NAT & REDUNDANCY" << WHITE << "                                                  â•‘\n";
        cout << "â•‘  [5] View NAT Table               - Active NAT translations          â•‘\n";
        cout << "â•‘  [6] HSRP Status                  - Hot Standby Router Protocol      â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  [0] Back to Main Menu                                               â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        cout << CYAN << "Routing & Switching >> " << RESET;
        int choice;
        cin >> choice;
        
        if (cin.fail()) {
            cin.clear();
            cin.ignore(10000, '\n');
            continue;
        }
        
        if (choice == 0) return;
        
        switch (choice) {
            case 1:
                viewRoutingTable();
                break;
            case 2:
                viewOSPFStatus();
                break;
            case 3:
                viewVLANConfiguration();
                break;
            case 4:
                viewTrunkLinks();
                break;
            case 5:
                viewNATTable();
                break;
            case 6:
                viewHSRPStatus();
                break;
            default:
                cout << RED << "\n[ERROR] Invalid choice!\n" << RESET;
                this_thread::sleep_for(chrono::seconds(1));
                continue;
        }
        
        cout << "\nPress Enter to continue...";
        cin.ignore();
        cin.get();
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYSTEM TESTS - Run on startup to verify critical functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


}
void runSystemTests() {
    cout << YELLOW << "\nğŸ§ª Running System Tests...\n" << RESET;
    
    // Test 1: CIDR Matching
    cout << CYAN << "\n[Test 1] CIDR Matching\n" << RESET;
    bool test1 = ipMatchesNetwork("203.0.113.1", "203.0.113.0/30") &&
                 ipMatchesNetwork("203.0.113.2", "203.0.113.0/30") &&
                 !ipMatchesNetwork("203.0.113.5", "203.0.113.0/30");
    cout << (test1 ? GREEN "âœ“ PASSED" : RED "âœ— FAILED") << RESET << "\n";
    
    // Test 2: Syslog Buffer
    cout << CYAN << "\n[Test 2] Syslog Buffer Management\n" << RESET;
    size_t initialSize = syslogDatabase.size();
    logToSyslog(INFO, SYSTEM, "TEST", "0.0.0.0", "TEST_EVENT", "Test message", "test");
    bool test2 = (syslogDatabase.size() <= MAX_SYSLOG_ENTRIES);
    cout << (test2 ? GREEN "âœ“ PASSED" : RED "âœ— FAILED") << RESET << "\n";
    
    // Test 3: Device Status
    cout << CYAN << "\n[Test 3] DHCP Service Check\n" << RESET;
    bool test3 = (networkDevices.find("MGMT-SRV1") != networkDevices.end());
    cout << (test3 ? GREEN "âœ“ PASSED" : RED "âœ— FAILED") << RESET << "\n";
    
    int passed = test1 + test2 + test3;
    cout << YELLOW << "\nğŸ“Š Test Results: " << passed << "/3 passed\n" << RESET;
    
    if (passed == 3) {
        cout << GREEN << "âœ… All systems operational!\n\n" << RESET;
    } else {
        cout << RED << "âš ï¸ Some tests failed - check implementation\n\n" << RESET;
    }
}
// âœ… YEH PURA FUNCTION COPY PASTE KARO
void exportNetworkDataToJSON() {
    ofstream jsonFile("network_data.json");
    
    jsonFile << "{\n";
    jsonFile << "  \"totalDevices\": " << totalDevices << ",\n";
    
    int online = 0;
    for (auto& p : networkDevices) {
        if (p.second.status == ONLINE) online++;
    }
    
    jsonFile << "  \"onlineDevices\": " << online << ",\n";
    jsonFile << "  \"offlineDevices\": " << (totalDevices - online) << ",\n";
    jsonFile << "  \"connections\": " << totalConnections << ",\n";
    
    jsonFile << "  \"dhcpPools\": [\n";
    bool first = true;
    for (auto& pool : dhcpPools) {
        if (!first) jsonFile << ",\n";
        first = false;
        int used = pool.second.getUsedCount();
        int total = pool.second.getTotalCount();
        jsonFile << "    {\"name\":\"" << pool.second.poolName << "\",";
        jsonFile << "\"used\":" << used << ",\"total\":" << total << "}";
    }
    jsonFile << "\n  ],\n";
    
    jsonFile << "  \"services\": {\n";
    jsonFile << "    \"dhcp\":\"" << (globalServices.dhcpOnline ? "online" : "offline") << "\",\n";
    jsonFile << "    \"email\":" << emailInbox.size() << ",\n";
    jsonFile << "    \"syslog\":" << syslogDatabase.size() << "\n";
    jsonFile << "  },\n";
    
    jsonFile << "  \"syslog\": [\n";
    int count = 0;
    for (auto it = syslogDatabase.rbegin(); it != syslogDatabase.rend() && count < 5; ++it, ++count) {
        if (count > 0) jsonFile << ",\n";
        jsonFile << "    {\"time\":\"" << it->timestamp << "\",";
        jsonFile << "\"severity\":\"" << it->getSeverityString() << "\",";
        jsonFile << "\"device\":\"" << it->sourceDevice << "\",";
        jsonFile << "\"message\":\"" << it->message << "\"}";
    }
    jsonFile << "\n  ]\n}\n";
    
    jsonFile.close();
}
// Main Function
int main() {
    srand(time(0));
    
    // Initialize everything
    initializeDHCPPools();
    initializeEmailDirectory();
    initializePhoneDirectory();
    initializeNetwork();
    initializeSampleEmails();
    initializeConnections();
    initializeExternalServers();
    initializeFirewallACLs();
    
    logToSyslog(NOTICE, SYSTEM, "MGMT-SRV1", "10.10.10.10",
               "SYSTEM_STARTUP",
               "Cloud TAP started successfully | Version 1.0.0", "system");
    
    // Display startup screen
    displayLogo();
    displaySystemInfo();
    cout << "\nPress Enter to start Cloud TAP...";
    cin.get();
    runSystemTests();
    
    int choice;
    while(true) {
        system("clear");
        displayLogo();
        
        cout << "\n" << CYAN << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        cout << "â•‘                         MAIN CONTROL PANEL                            â•‘\n";
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        cout << WHITE;
        cout << "â•‘                                                                       â•‘\n";
        cout << "â•‘  [1] NETWORK MANAGEMENT                                               â•‘\n";
        cout << "â•‘  [2] NETWORK TOOLS (Simulation Mode)                                  â•‘\n";
        cout << "â•‘  [3] ROUTING & SWITCHING                                              â•‘\n";
        cout << "â•‘  [4] NETWORK ANALYSIS                                                 â•‘\n";
        cout << "â•‘  [5] REAL NETWORK ANALYSIS (API Integration)                          â•‘\n";
        cout << "â•‘  [6] ADVANCED FEATURES                                                â•‘\n";
        cout << "â•‘  [7] REPORTS & STATISTICS                                             â•‘\n";
        cout << "â•‘  [8] Help & Documentation                                             â•‘\n";
        cout << "â•‘  [9] Export to Web Dashboard                                          â•‘\n";  // â¬…ï¸ YEH LINE ADD KARO
        cout << "â•‘  [0] EXIT                                                             â•‘\n";
        cout << "â•‘                                                                       â•‘\n";
        cout << CYAN;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        cout << RESET;
        
        int choice = getValidatedInt(CYAN "Cloud TAP >> " RESET, 0, 9);  // âœ… Changed from 0-9 to 0-8
        
        switch(choice) {
            case 0:
                cout << YELLOW << "\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
                cout << "â•‘          Thank you for using Cloud TAP!                   â•‘\n";
                cout << "â•‘          Shutting down network systems...                 â•‘\n";
                cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n" << RESET;
                return 0;
            case 1:
                networkManagementMenu();
                break;
            case 2:
                networkToolsMenu();
                break;
            case 3:
                routingAndSwitchingMenu();
                break;
            case 4:  // âœ… Was option 5, now option 4
                networkAnalysisMenu();
                break;
            case 5:  // âœ… Was option 6, now option 5
                cout << YELLOW << "\n[!] Real Network Analysis (API Integration) coming soon...\n" << RESET;
                cout << "\nPress Enter to continue...";
                cin.ignore();
                cin.get();
                break;
            case 6:  // âœ… Was option 7, now option 6
                cout << YELLOW << "\n[!] Advanced Features coming soon...\n" << RESET;
                cout << "\nPress Enter to continue...";
                cin.ignore();
                cin.get();
                break;
            case 7:  // âœ… Was option 8, now option 7
                cout << YELLOW << "\n[!] Reports & Statistics coming soon...\n" << RESET;
                cout << "\nPress Enter to continue...";
                cin.ignore();
                cin.get();
                break;
            case 8:  // âœ… Was option 9, now option 8
                cout << YELLOW << "\n[!] Help & Documentation coming soon...\n" << RESET;
                cout << "\nPress Enter to continue...";
                cin.ignore();
                cin.get();
                break;
            // âœ… EXISTING CODE KE SAATH YEH ADD KARO

case 9:  // â¬…ï¸ Naya option
    exportNetworkDataToJSON();
    cout << GREEN << "âœ… Data exported to network_data.json\n" << RESET;
    cout << "\nPress Enter...";
    cin.ignore();
    cin.get();
    break;    
            default:
                cout << RED << "\n[ERROR] Invalid choice! Please select 0-9.\n" << RESET;
                cout << "\nPress Enter to continue...";
                cin.ignore();
                cin.get();
        }
    }
    
    return 0;
}